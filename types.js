/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 *
 * @flow
 */
 
import * as Immutable from 'immutable'
 
class StateImpl extends Immutable.Record({
        screenExpressions: undefined, nextExprId: undefined, activeDrags: undefined}) {
    withScreenExpressions(screenExpressions) {
        return this.set('screenExpressions', screenExpressions)
    }
    withNextExprId(nextExprId) {
        return this.set('nextExprId', nextExprId)
    }
    withActiveDrags(activeDrags) {
        return this.set('activeDrags', activeDrags)
    }
    updateScreenExpressions(updater) {
        return this.set('screenExpressions', updater(this.screenExpressions))
    }
    updateNextExprId(updater) {
        return this.set('nextExprId', updater(this.nextExprId))
    }
    updateActiveDrags(updater) {
        return this.set('activeDrags', updater(this.activeDrags))
    }
}

export type State = {
    screenExpressions: Immutable.Map<number, ScreenExpression>,
    nextExprId: number,
    activeDrags: Immutable.Map<number, DragData>,
    withScreenExpressions: (screenExpressions: Immutable.Map<number, ScreenExpression>) => State,
    withNextExprId: (nextExprId: number) => State,
    withActiveDrags: (activeDrags: Immutable.Map<number, DragData>) => State,
    updateScreenExpressions: (updater: (screenExpressions: Immutable.Map<number, ScreenExpression>) => Immutable.Map<number, ScreenExpression>) => State,
    updateNextExprId: (updater: (nextExprId: number) => number) => State,
    updateActiveDrags: (updater: (activeDrags: Immutable.Map<number, DragData>) => Immutable.Map<number, DragData>) => State,
    toJS: () => any,
};

export const newState = (screenExpressions: Immutable.Map<number, ScreenExpression>, nextExprId: number, activeDrags: Immutable.Map<number, DragData>): State => (new StateImpl({
    screenExpressions,
    nextExprId,
    activeDrags,
}));

export type Reset = {
    type: 'reset',
};

export const newReset = (): Reset => ({
    type: 'reset',
});

export type AddExpression = {
    type: 'addExpression',
    screenExpr: ScreenExpression,
};

export const newAddExpression = (screenExpr: ScreenExpression): AddExpression => ({
    type: 'addExpression',
    screenExpr,
});

export type MoveExpression = {
    type: 'moveExpression',
    exprId: number,
    pos: CanvasPoint,
};

export const newMoveExpression = (exprId: number, pos: CanvasPoint): MoveExpression => ({
    type: 'moveExpression',
    exprId,
    pos,
});

export type DecomposeExpression = {
    type: 'decomposeExpression',
    path: ExprPath,
    targetPos: CanvasPoint,
};

export const newDecomposeExpression = (path: ExprPath, targetPos: CanvasPoint): DecomposeExpression => ({
    type: 'decomposeExpression',
    path,
    targetPos,
});

export type InsertAsArg = {
    type: 'insertAsArg',
    argExprId: number,
    path: ExprPath,
};

export const newInsertAsArg = (argExprId: number, path: ExprPath): InsertAsArg => ({
    type: 'insertAsArg',
    argExprId,
    path,
});

export type InsertAsBody = {
    type: 'insertAsBody',
    bodyExprId: number,
    path: ExprPath,
};

export const newInsertAsBody = (bodyExprId: number, path: ExprPath): InsertAsBody => ({
    type: 'insertAsBody',
    bodyExprId,
    path,
});

export type EvaluateExpression = {
    type: 'evaluateExpression',
    exprId: number,
    targetPos: CanvasPoint,
};

export const newEvaluateExpression = (exprId: number, targetPos: CanvasPoint): EvaluateExpression => ({
    type: 'evaluateExpression',
    exprId,
    targetPos,
});

export type FingerDown = {
    type: 'fingerDown',
    fingerId: number,
    screenPos: ScreenPoint,
};

export const newFingerDown = (fingerId: number, screenPos: ScreenPoint): FingerDown => ({
    type: 'fingerDown',
    fingerId,
    screenPos,
});

export type FingerMove = {
    type: 'fingerMove',
    fingerId: number,
    screenPos: ScreenPoint,
};

export const newFingerMove = (fingerId: number, screenPos: ScreenPoint): FingerMove => ({
    type: 'fingerMove',
    fingerId,
    screenPos,
});

export type FingerUp = {
    type: 'fingerUp',
    fingerId: number,
    screenPos: ScreenPoint,
};

export const newFingerUp = (fingerId: number, screenPos: ScreenPoint): FingerUp => ({
    type: 'fingerUp',
    fingerId,
    screenPos,
});

export type Action = Reset | AddExpression | MoveExpression | DecomposeExpression | InsertAsArg | InsertAsBody | EvaluateExpression | FingerDown | FingerMove | FingerUp;

export type ActionVisitor<T> = {
    reset: (reset: Reset) => T,
    addExpression: (addExpression: AddExpression) => T,
    moveExpression: (moveExpression: MoveExpression) => T,
    decomposeExpression: (decomposeExpression: DecomposeExpression) => T,
    insertAsArg: (insertAsArg: InsertAsArg) => T,
    insertAsBody: (insertAsBody: InsertAsBody) => T,
    evaluateExpression: (evaluateExpression: EvaluateExpression) => T,
    fingerDown: (fingerDown: FingerDown) => T,
    fingerMove: (fingerMove: FingerMove) => T,
    fingerUp: (fingerUp: FingerUp) => T,
}

export const matchAction = function<T>(action: Action, visitor: ActionVisitor<T>): T {
    switch (action.type) {
        case 'reset':
            return visitor.reset(action);
        case 'addExpression':
            return visitor.addExpression(action);
        case 'moveExpression':
            return visitor.moveExpression(action);
        case 'decomposeExpression':
            return visitor.decomposeExpression(action);
        case 'insertAsArg':
            return visitor.insertAsArg(action);
        case 'insertAsBody':
            return visitor.insertAsBody(action);
        case 'evaluateExpression':
            return visitor.evaluateExpression(action);
        case 'fingerDown':
            return visitor.fingerDown(action);
        case 'fingerMove':
            return visitor.fingerMove(action);
        case 'fingerUp':
            return visitor.fingerUp(action);
        default:
            throw new Error('Unexpected type: ' + action.type);
    }
};

class LambdaImpl extends Immutable.Record({
        type: undefined, varName: undefined, body: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    withBody(body) {
        return this.set('body', body)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
    updateBody(updater) {
        return this.set('body', updater(this.body))
    }
}

export type Lambda = {
    type: 'lambda',
    varName: string,
    body: Expression,
    withVarName: (varName: string) => Lambda,
    withBody: (body: Expression) => Lambda,
    updateVarName: (updater: (varName: string) => string) => Lambda,
    updateBody: (updater: (body: Expression) => Expression) => Lambda,
    toJS: () => any,
};

export const newLambda = (varName: string, body: Expression): Lambda => (new LambdaImpl({
    type: 'lambda',
    varName,
    body,
}));

class FuncCallImpl extends Immutable.Record({
        type: undefined, func: undefined, arg: undefined}) {
    withFunc(func) {
        return this.set('func', func)
    }
    withArg(arg) {
        return this.set('arg', arg)
    }
    updateFunc(updater) {
        return this.set('func', updater(this.func))
    }
    updateArg(updater) {
        return this.set('arg', updater(this.arg))
    }
}

export type FuncCall = {
    type: 'funcCall',
    func: Expression,
    arg: Expression,
    withFunc: (func: Expression) => FuncCall,
    withArg: (arg: Expression) => FuncCall,
    updateFunc: (updater: (func: Expression) => Expression) => FuncCall,
    updateArg: (updater: (arg: Expression) => Expression) => FuncCall,
    toJS: () => any,
};

export const newFuncCall = (func: Expression, arg: Expression): FuncCall => (new FuncCallImpl({
    type: 'funcCall',
    func,
    arg,
}));

class VariableImpl extends Immutable.Record({
        type: undefined, varName: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
}

export type Variable = {
    type: 'variable',
    varName: string,
    withVarName: (varName: string) => Variable,
    updateVarName: (updater: (varName: string) => string) => Variable,
    toJS: () => any,
};

export const newVariable = (varName: string): Variable => (new VariableImpl({
    type: 'variable',
    varName,
}));

export type Expression = Lambda | FuncCall | Variable;

export type ExpressionVisitor<T> = {
    lambda: (lambda: Lambda) => T,
    funcCall: (funcCall: FuncCall) => T,
    variable: (variable: Variable) => T,
}

export const matchExpression = function<T>(expression: Expression, visitor: ExpressionVisitor<T>): T {
    switch (expression.type) {
        case 'lambda':
            return visitor.lambda(expression);
        case 'funcCall':
            return visitor.funcCall(expression);
        case 'variable':
            return visitor.variable(expression);
        default:
            throw new Error('Unexpected type: ' + expression.type);
    }
};

export type Slot = {
    isValue: boolean,
    expr: EvalExpression,
    originalVarName: string
};

export type VarMarker = number;

class EvalLambdaImpl extends Immutable.Record({
        type: undefined, varMarker: undefined, originalVarName: undefined, body: undefined}) {
    withVarMarker(varMarker) {
        return this.set('varMarker', varMarker)
    }
    withOriginalVarName(originalVarName) {
        return this.set('originalVarName', originalVarName)
    }
    withBody(body) {
        return this.set('body', body)
    }
    updateVarMarker(updater) {
        return this.set('varMarker', updater(this.varMarker))
    }
    updateOriginalVarName(updater) {
        return this.set('originalVarName', updater(this.originalVarName))
    }
    updateBody(updater) {
        return this.set('body', updater(this.body))
    }
}

export type EvalLambda = {
    type: 'evalLambda',
    varMarker: VarMarker,
    originalVarName: string,
    body: EvalExpression,
    withVarMarker: (varMarker: VarMarker) => EvalLambda,
    withOriginalVarName: (originalVarName: string) => EvalLambda,
    withBody: (body: EvalExpression) => EvalLambda,
    updateVarMarker: (updater: (varMarker: VarMarker) => VarMarker) => EvalLambda,
    updateOriginalVarName: (updater: (originalVarName: string) => string) => EvalLambda,
    updateBody: (updater: (body: EvalExpression) => EvalExpression) => EvalLambda,
    toJS: () => any,
};

export const newEvalLambda = (varMarker: VarMarker, originalVarName: string, body: EvalExpression): EvalLambda => (new EvalLambdaImpl({
    type: 'evalLambda',
    varMarker,
    originalVarName,
    body,
}));

class EvalFuncCallImpl extends Immutable.Record({
        type: undefined, func: undefined, arg: undefined}) {
    withFunc(func) {
        return this.set('func', func)
    }
    withArg(arg) {
        return this.set('arg', arg)
    }
    updateFunc(updater) {
        return this.set('func', updater(this.func))
    }
    updateArg(updater) {
        return this.set('arg', updater(this.arg))
    }
}

export type EvalFuncCall = {
    type: 'evalFuncCall',
    func: EvalExpression,
    arg: EvalExpression,
    withFunc: (func: EvalExpression) => EvalFuncCall,
    withArg: (arg: EvalExpression) => EvalFuncCall,
    updateFunc: (updater: (func: EvalExpression) => EvalExpression) => EvalFuncCall,
    updateArg: (updater: (arg: EvalExpression) => EvalExpression) => EvalFuncCall,
    toJS: () => any,
};

export const newEvalFuncCall = (func: EvalExpression, arg: EvalExpression): EvalFuncCall => (new EvalFuncCallImpl({
    type: 'evalFuncCall',
    func,
    arg,
}));

class EvalBoundVariableImpl extends Immutable.Record({
        type: undefined, slot: undefined}) {
    withSlot(slot) {
        return this.set('slot', slot)
    }
    updateSlot(updater) {
        return this.set('slot', updater(this.slot))
    }
}

export type EvalBoundVariable = {
    type: 'evalBoundVariable',
    slot: Slot,
    withSlot: (slot: Slot) => EvalBoundVariable,
    updateSlot: (updater: (slot: Slot) => Slot) => EvalBoundVariable,
    toJS: () => any,
};

export const newEvalBoundVariable = (slot: Slot): EvalBoundVariable => (new EvalBoundVariableImpl({
    type: 'evalBoundVariable',
    slot,
}));

class EvalUnboundVariableImpl extends Immutable.Record({
        type: undefined, varMarker: undefined, originalVarName: undefined}) {
    withVarMarker(varMarker) {
        return this.set('varMarker', varMarker)
    }
    withOriginalVarName(originalVarName) {
        return this.set('originalVarName', originalVarName)
    }
    updateVarMarker(updater) {
        return this.set('varMarker', updater(this.varMarker))
    }
    updateOriginalVarName(updater) {
        return this.set('originalVarName', updater(this.originalVarName))
    }
}

export type EvalUnboundVariable = {
    type: 'evalUnboundVariable',
    varMarker: VarMarker,
    originalVarName: string,
    withVarMarker: (varMarker: VarMarker) => EvalUnboundVariable,
    withOriginalVarName: (originalVarName: string) => EvalUnboundVariable,
    updateVarMarker: (updater: (varMarker: VarMarker) => VarMarker) => EvalUnboundVariable,
    updateOriginalVarName: (updater: (originalVarName: string) => string) => EvalUnboundVariable,
    toJS: () => any,
};

export const newEvalUnboundVariable = (varMarker: VarMarker, originalVarName: string): EvalUnboundVariable => (new EvalUnboundVariableImpl({
    type: 'evalUnboundVariable',
    varMarker,
    originalVarName,
}));

class EvalFreeVariableImpl extends Immutable.Record({
        type: undefined, varName: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
}

export type EvalFreeVariable = {
    type: 'evalFreeVariable',
    varName: string,
    withVarName: (varName: string) => EvalFreeVariable,
    updateVarName: (updater: (varName: string) => string) => EvalFreeVariable,
    toJS: () => any,
};

export const newEvalFreeVariable = (varName: string): EvalFreeVariable => (new EvalFreeVariableImpl({
    type: 'evalFreeVariable',
    varName,
}));

export type EvalExpression = EvalLambda | EvalFuncCall | EvalBoundVariable | EvalUnboundVariable | EvalFreeVariable;

export type EvalExpressionVisitor<T> = {
    evalLambda: (evalLambda: EvalLambda) => T,
    evalFuncCall: (evalFuncCall: EvalFuncCall) => T,
    evalBoundVariable: (evalBoundVariable: EvalBoundVariable) => T,
    evalUnboundVariable: (evalUnboundVariable: EvalUnboundVariable) => T,
    evalFreeVariable: (evalFreeVariable: EvalFreeVariable) => T,
}

export const matchEvalExpression = function<T>(evalExpression: EvalExpression, visitor: EvalExpressionVisitor<T>): T {
    switch (evalExpression.type) {
        case 'evalLambda':
            return visitor.evalLambda(evalExpression);
        case 'evalFuncCall':
            return visitor.evalFuncCall(evalExpression);
        case 'evalBoundVariable':
            return visitor.evalBoundVariable(evalExpression);
        case 'evalUnboundVariable':
            return visitor.evalUnboundVariable(evalExpression);
        case 'evalFreeVariable':
            return visitor.evalFreeVariable(evalExpression);
        default:
            throw new Error('Unexpected type: ' + evalExpression.type);
    }
};

class UserLambdaImpl extends Immutable.Record({
        type: undefined, varName: undefined, body: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    withBody(body) {
        return this.set('body', body)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
    updateBody(updater) {
        return this.set('body', updater(this.body))
    }
}

export type UserLambda = {
    type: 'userLambda',
    varName: string,
    body: ?UserExpression,
    withVarName: (varName: string) => UserLambda,
    withBody: (body: ?UserExpression) => UserLambda,
    updateVarName: (updater: (varName: string) => string) => UserLambda,
    updateBody: (updater: (body: ?UserExpression) => ?UserExpression) => UserLambda,
    toJS: () => any,
};

export const newUserLambda = (varName: string, body: ?UserExpression): UserLambda => (new UserLambdaImpl({
    type: 'userLambda',
    varName,
    body,
}));

class UserFuncCallImpl extends Immutable.Record({
        type: undefined, func: undefined, arg: undefined}) {
    withFunc(func) {
        return this.set('func', func)
    }
    withArg(arg) {
        return this.set('arg', arg)
    }
    updateFunc(updater) {
        return this.set('func', updater(this.func))
    }
    updateArg(updater) {
        return this.set('arg', updater(this.arg))
    }
}

export type UserFuncCall = {
    type: 'userFuncCall',
    func: UserExpression,
    arg: UserExpression,
    withFunc: (func: UserExpression) => UserFuncCall,
    withArg: (arg: UserExpression) => UserFuncCall,
    updateFunc: (updater: (func: UserExpression) => UserExpression) => UserFuncCall,
    updateArg: (updater: (arg: UserExpression) => UserExpression) => UserFuncCall,
    toJS: () => any,
};

export const newUserFuncCall = (func: UserExpression, arg: UserExpression): UserFuncCall => (new UserFuncCallImpl({
    type: 'userFuncCall',
    func,
    arg,
}));

class UserVariableImpl extends Immutable.Record({
        type: undefined, varName: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
}

export type UserVariable = {
    type: 'userVariable',
    varName: string,
    withVarName: (varName: string) => UserVariable,
    updateVarName: (updater: (varName: string) => string) => UserVariable,
    toJS: () => any,
};

export const newUserVariable = (varName: string): UserVariable => (new UserVariableImpl({
    type: 'userVariable',
    varName,
}));

class UserReferenceImpl extends Immutable.Record({
        type: undefined, defName: undefined}) {
    withDefName(defName) {
        return this.set('defName', defName)
    }
    updateDefName(updater) {
        return this.set('defName', updater(this.defName))
    }
}

export type UserReference = {
    type: 'userReference',
    defName: string,
    withDefName: (defName: string) => UserReference,
    updateDefName: (updater: (defName: string) => string) => UserReference,
    toJS: () => any,
};

export const newUserReference = (defName: string): UserReference => (new UserReferenceImpl({
    type: 'userReference',
    defName,
}));

export type UserExpression = UserLambda | UserFuncCall | UserVariable | UserReference;

export type UserExpressionVisitor<T> = {
    userLambda: (userLambda: UserLambda) => T,
    userFuncCall: (userFuncCall: UserFuncCall) => T,
    userVariable: (userVariable: UserVariable) => T,
    userReference: (userReference: UserReference) => T,
}

export const matchUserExpression = function<T>(userExpression: UserExpression, visitor: UserExpressionVisitor<T>): T {
    switch (userExpression.type) {
        case 'userLambda':
            return visitor.userLambda(userExpression);
        case 'userFuncCall':
            return visitor.userFuncCall(userExpression);
        case 'userVariable':
            return visitor.userVariable(userExpression);
        case 'userReference':
            return visitor.userReference(userExpression);
        default:
            throw new Error('Unexpected type: ' + userExpression.type);
    }
};

class ScreenExpressionImpl extends Immutable.Record({
        expr: undefined, pos: undefined}) {
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withPos(pos) {
        return this.set('pos', pos)
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updatePos(updater) {
        return this.set('pos', updater(this.pos))
    }
}

export type ScreenExpression = {
    expr: UserExpression,
    pos: CanvasPoint,
    withExpr: (expr: UserExpression) => ScreenExpression,
    withPos: (pos: CanvasPoint) => ScreenExpression,
    updateExpr: (updater: (expr: UserExpression) => UserExpression) => ScreenExpression,
    updatePos: (updater: (pos: CanvasPoint) => CanvasPoint) => ScreenExpression,
    toJS: () => any,
};

export const newScreenExpression = (expr: UserExpression, pos: CanvasPoint): ScreenExpression => (new ScreenExpressionImpl({
    expr,
    pos,
}));

class CanvasPointImpl extends Immutable.Record({
        canvasX: undefined, canvasY: undefined}) {
    withCanvasX(canvasX) {
        return this.set('canvasX', canvasX)
    }
    withCanvasY(canvasY) {
        return this.set('canvasY', canvasY)
    }
    updateCanvasX(updater) {
        return this.set('canvasX', updater(this.canvasX))
    }
    updateCanvasY(updater) {
        return this.set('canvasY', updater(this.canvasY))
    }
}

export type CanvasPoint = {
    canvasX: number,
    canvasY: number,
    withCanvasX: (canvasX: number) => CanvasPoint,
    withCanvasY: (canvasY: number) => CanvasPoint,
    updateCanvasX: (updater: (canvasX: number) => number) => CanvasPoint,
    updateCanvasY: (updater: (canvasY: number) => number) => CanvasPoint,
    toJS: () => any,
};

export const newCanvasPoint = (canvasX: number, canvasY: number): CanvasPoint => (new CanvasPointImpl({
    canvasX,
    canvasY,
}));

class PointDifferenceImpl extends Immutable.Record({
        dx: undefined, dy: undefined}) {
    withDx(dx) {
        return this.set('dx', dx)
    }
    withDy(dy) {
        return this.set('dy', dy)
    }
    updateDx(updater) {
        return this.set('dx', updater(this.dx))
    }
    updateDy(updater) {
        return this.set('dy', updater(this.dy))
    }
}

export type PointDifference = {
    dx: number,
    dy: number,
    withDx: (dx: number) => PointDifference,
    withDy: (dy: number) => PointDifference,
    updateDx: (updater: (dx: number) => number) => PointDifference,
    updateDy: (updater: (dy: number) => number) => PointDifference,
    toJS: () => any,
};

export const newPointDifference = (dx: number, dy: number): PointDifference => (new PointDifferenceImpl({
    dx,
    dy,
}));

class ScreenPointImpl extends Immutable.Record({
        screenX: undefined, screenY: undefined}) {
    withScreenX(screenX) {
        return this.set('screenX', screenX)
    }
    withScreenY(screenY) {
        return this.set('screenY', screenY)
    }
    updateScreenX(updater) {
        return this.set('screenX', updater(this.screenX))
    }
    updateScreenY(updater) {
        return this.set('screenY', updater(this.screenY))
    }
}

export type ScreenPoint = {
    screenX: number,
    screenY: number,
    withScreenX: (screenX: number) => ScreenPoint,
    withScreenY: (screenY: number) => ScreenPoint,
    updateScreenX: (updater: (screenX: number) => number) => ScreenPoint,
    updateScreenY: (updater: (screenY: number) => number) => ScreenPoint,
    toJS: () => any,
};

export const newScreenPoint = (screenX: number, screenY: number): ScreenPoint => (new ScreenPointImpl({
    screenX,
    screenY,
}));

class ScreenRectImpl extends Immutable.Record({
        topLeft: undefined, bottomRight: undefined}) {
    withTopLeft(topLeft) {
        return this.set('topLeft', topLeft)
    }
    withBottomRight(bottomRight) {
        return this.set('bottomRight', bottomRight)
    }
    updateTopLeft(updater) {
        return this.set('topLeft', updater(this.topLeft))
    }
    updateBottomRight(updater) {
        return this.set('bottomRight', updater(this.bottomRight))
    }
}

export type ScreenRect = {
    topLeft: ScreenPoint,
    bottomRight: ScreenPoint,
    withTopLeft: (topLeft: ScreenPoint) => ScreenRect,
    withBottomRight: (bottomRight: ScreenPoint) => ScreenRect,
    updateTopLeft: (updater: (topLeft: ScreenPoint) => ScreenPoint) => ScreenRect,
    updateBottomRight: (updater: (bottomRight: ScreenPoint) => ScreenPoint) => ScreenRect,
    toJS: () => any,
};

export const newScreenRect = (topLeft: ScreenPoint, bottomRight: ScreenPoint): ScreenRect => (new ScreenRectImpl({
    topLeft,
    bottomRight,
}));

export type PathComponent = 'func' | 'arg' | 'body';

class ExprPathImpl extends Immutable.Record({
        exprId: undefined, pathSteps: undefined}) {
    withExprId(exprId) {
        return this.set('exprId', exprId)
    }
    withPathSteps(pathSteps) {
        return this.set('pathSteps', pathSteps)
    }
    updateExprId(updater) {
        return this.set('exprId', updater(this.exprId))
    }
    updatePathSteps(updater) {
        return this.set('pathSteps', updater(this.pathSteps))
    }
}

export type ExprPath = {
    exprId: number,
    pathSteps: Immutable.List<PathComponent>,
    withExprId: (exprId: number) => ExprPath,
    withPathSteps: (pathSteps: Immutable.List<PathComponent>) => ExprPath,
    updateExprId: (updater: (exprId: number) => number) => ExprPath,
    updatePathSteps: (updater: (pathSteps: Immutable.List<PathComponent>) => Immutable.List<PathComponent>) => ExprPath,
    toJS: () => any,
};

export const newExprPath = (exprId: number, pathSteps: Immutable.List<PathComponent>): ExprPath => (new ExprPathImpl({
    exprId,
    pathSteps,
}));

class DragDataImpl extends Immutable.Record({
        offset: undefined, screenExpr: undefined}) {
    withOffset(offset) {
        return this.set('offset', offset)
    }
    withScreenExpr(screenExpr) {
        return this.set('screenExpr', screenExpr)
    }
    updateOffset(updater) {
        return this.set('offset', updater(this.offset))
    }
    updateScreenExpr(updater) {
        return this.set('screenExpr', updater(this.screenExpr))
    }
}

export type DragData = {
    offset: PointDifference,
    screenExpr: ScreenExpression,
    withOffset: (offset: PointDifference) => DragData,
    withScreenExpr: (screenExpr: ScreenExpression) => DragData,
    updateOffset: (updater: (offset: PointDifference) => PointDifference) => DragData,
    updateScreenExpr: (updater: (screenExpr: ScreenExpression) => ScreenExpression) => DragData,
    toJS: () => any,
};

export const newDragData = (offset: PointDifference, screenExpr: ScreenExpression): DragData => (new DragDataImpl({
    offset,
    screenExpr,
}));

class AddToTopLevelImpl extends Immutable.Record({
        type: undefined, screenExpr: undefined}) {
    withScreenExpr(screenExpr) {
        return this.set('screenExpr', screenExpr)
    }
    updateScreenExpr(updater) {
        return this.set('screenExpr', updater(this.screenExpr))
    }
}

export type AddToTopLevel = {
    type: 'addToTopLevel',
    screenExpr: ScreenExpression,
    withScreenExpr: (screenExpr: ScreenExpression) => AddToTopLevel,
    updateScreenExpr: (updater: (screenExpr: ScreenExpression) => ScreenExpression) => AddToTopLevel,
    toJS: () => any,
};

export const newAddToTopLevel = (screenExpr: ScreenExpression): AddToTopLevel => (new AddToTopLevelImpl({
    type: 'addToTopLevel',
    screenExpr,
}));

export type DropResult = AddToTopLevel;

export type DropResultVisitor<T> = {
    addToTopLevel: (addToTopLevel: AddToTopLevel) => T,
}

export const matchDropResult = function<T>(dropResult: DropResult, visitor: DropResultVisitor<T>): T {
    switch (dropResult.type) {
        case 'addToTopLevel':
            return visitor.addToTopLevel(dropResult);
        default:
            throw new Error('Unexpected type: ' + dropResult.type);
    }
};

