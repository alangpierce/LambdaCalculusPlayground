/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 */
import {buildUnionCaseClass, buildValueClass} from './types-lib'
import {IList, IMap, ISet} from './types-collections'

 
export const State = buildValueClass('State', ['canvasExpressions', 'nextExprId', 'canvasDefinitions', 'definitions', 'pendingResults', 'activeDrags', 'highlightedExprs', 'highlightedEmptyBodies']);

export const newState = (canvasExpressions: IMap<number, CanvasExpression>, nextExprId: number, canvasDefinitions: IMap<string, CanvasPoint>, definitions: IMap<string, ?UserExpression>, pendingResults: IMap<number, PendingResult>, activeDrags: IMap<number, DragData>, highlightedExprs: ISet<ExprPath>, highlightedEmptyBodies: ISet<ExprPath>): State => (new State({
    canvasExpressions,
    nextExprId,
    canvasDefinitions,
    definitions,
    pendingResults,
    activeDrags,
    highlightedExprs,
    highlightedEmptyBodies,
}));

export const Reset = buildUnionCaseClass('reset', []);

export const newReset = (): Reset => (new Reset({
    type: 'reset',
}));

export const AddExpression = buildUnionCaseClass('addExpression', ['canvasExpr']);

export const newAddExpression = (canvasExpr: CanvasExpression): AddExpression => (new AddExpression({
    type: 'addExpression',
    canvasExpr,
}));

export const PlaceDefinition = buildUnionCaseClass('placeDefinition', ['defName', 'screenPos']);

export const newPlaceDefinition = (defName: string, screenPos: ScreenPoint): PlaceDefinition => (new PlaceDefinition({
    type: 'placeDefinition',
    defName,
    screenPos,
}));

export const MoveExpression = buildUnionCaseClass('moveExpression', ['exprId', 'pos']);

export const newMoveExpression = (exprId: number, pos: CanvasPoint): MoveExpression => (new MoveExpression({
    type: 'moveExpression',
    exprId,
    pos,
}));

export const DecomposeExpressionAction = buildUnionCaseClass('decomposeExpressionAction', ['path', 'targetPos']);

export const newDecomposeExpressionAction = (path: ExprPath, targetPos: CanvasPoint): DecomposeExpressionAction => (new DecomposeExpressionAction({
    type: 'decomposeExpressionAction',
    path,
    targetPos,
}));

export const InsertAsArg = buildUnionCaseClass('insertAsArg', ['argExprId', 'path']);

export const newInsertAsArg = (argExprId: number, path: ExprPath): InsertAsArg => (new InsertAsArg({
    type: 'insertAsArg',
    argExprId,
    path,
}));

export const InsertAsBody = buildUnionCaseClass('insertAsBody', ['bodyExprId', 'path']);

export const newInsertAsBody = (bodyExprId: number, path: ExprPath): InsertAsBody => (new InsertAsBody({
    type: 'insertAsBody',
    bodyExprId,
    path,
}));

export const EvaluateExpression = buildUnionCaseClass('evaluateExpression', ['exprId']);

export const newEvaluateExpression = (exprId: number): EvaluateExpression => (new EvaluateExpression({
    type: 'evaluateExpression',
    exprId,
}));

export const PlacePendingResult = buildUnionCaseClass('placePendingResult', ['exprId', 'width', 'height']);

export const newPlacePendingResult = (exprId: number, width: number, height: number): PlacePendingResult => (new PlacePendingResult({
    type: 'placePendingResult',
    exprId,
    width,
    height,
}));

export const FingerDown = buildUnionCaseClass('fingerDown', ['fingerId', 'screenPos']);

export const newFingerDown = (fingerId: number, screenPos: ScreenPoint): FingerDown => (new FingerDown({
    type: 'fingerDown',
    fingerId,
    screenPos,
}));

export const FingerMove = buildUnionCaseClass('fingerMove', ['fingerId', 'screenPos']);

export const newFingerMove = (fingerId: number, screenPos: ScreenPoint): FingerMove => (new FingerMove({
    type: 'fingerMove',
    fingerId,
    screenPos,
}));

export const FingerUp = buildUnionCaseClass('fingerUp', ['fingerId', 'screenPos']);

export const newFingerUp = (fingerId: number, screenPos: ScreenPoint): FingerUp => (new FingerUp({
    type: 'fingerUp',
    fingerId,
    screenPos,
}));

export const Lambda = buildUnionCaseClass('lambda', ['varName', 'body']);

export const newLambda = (varName: string, body: Expression): Lambda => (new Lambda({
    type: 'lambda',
    varName,
    body,
}));

export const FuncCall = buildUnionCaseClass('funcCall', ['func', 'arg']);

export const newFuncCall = (func: Expression, arg: Expression): FuncCall => (new FuncCall({
    type: 'funcCall',
    func,
    arg,
}));

export const Variable = buildUnionCaseClass('variable', ['varName']);

export const newVariable = (varName: string): Variable => (new Variable({
    type: 'variable',
    varName,
}));



export const EvalLambda = buildUnionCaseClass('evalLambda', ['varMarker', 'originalVarName', 'body']);

export const newEvalLambda = (varMarker: VarMarker, originalVarName: string, body: EvalExpression): EvalLambda => (new EvalLambda({
    type: 'evalLambda',
    varMarker,
    originalVarName,
    body,
}));

export const EvalFuncCall = buildUnionCaseClass('evalFuncCall', ['func', 'arg']);

export const newEvalFuncCall = (func: EvalExpression, arg: EvalExpression): EvalFuncCall => (new EvalFuncCall({
    type: 'evalFuncCall',
    func,
    arg,
}));

export const EvalBoundVariable = buildUnionCaseClass('evalBoundVariable', ['slot']);

export const newEvalBoundVariable = (slot: Slot): EvalBoundVariable => (new EvalBoundVariable({
    type: 'evalBoundVariable',
    slot,
}));

export const EvalUnboundVariable = buildUnionCaseClass('evalUnboundVariable', ['varMarker', 'originalVarName']);

export const newEvalUnboundVariable = (varMarker: VarMarker, originalVarName: string): EvalUnboundVariable => (new EvalUnboundVariable({
    type: 'evalUnboundVariable',
    varMarker,
    originalVarName,
}));

export const EvalFreeVariable = buildUnionCaseClass('evalFreeVariable', ['varName']);

export const newEvalFreeVariable = (varName: string): EvalFreeVariable => (new EvalFreeVariable({
    type: 'evalFreeVariable',
    varName,
}));

export const UserLambda = buildUnionCaseClass('userLambda', ['varName', 'body']);

export const newUserLambda = (varName: string, body: ?UserExpression): UserLambda => (new UserLambda({
    type: 'userLambda',
    varName,
    body,
}));

export const UserFuncCall = buildUnionCaseClass('userFuncCall', ['func', 'arg']);

export const newUserFuncCall = (func: UserExpression, arg: UserExpression): UserFuncCall => (new UserFuncCall({
    type: 'userFuncCall',
    func,
    arg,
}));

export const UserVariable = buildUnionCaseClass('userVariable', ['varName']);

export const newUserVariable = (varName: string): UserVariable => (new UserVariable({
    type: 'userVariable',
    varName,
}));

export const UserReference = buildUnionCaseClass('userReference', ['defName']);

export const newUserReference = (defName: string): UserReference => (new UserReference({
    type: 'userReference',
    defName,
}));


export const CanvasExpression = buildValueClass('CanvasExpression', ['expr', 'pos']);

export const newCanvasExpression = (expr: UserExpression, pos: CanvasPoint): CanvasExpression => (new CanvasExpression({
    expr,
    pos,
}));


export const PendingResult = buildValueClass('PendingResult', ['expr', 'sourceExprId']);

export const newPendingResult = (expr: UserExpression, sourceExprId: number): PendingResult => (new PendingResult({
    expr,
    sourceExprId,
}));


export const DisplayState = buildValueClass('DisplayState', ['screenExpressions', 'screenDefinitions', 'measureRequests']);

export const newDisplayState = (screenExpressions: IList<ScreenExpression>, screenDefinitions: IList<ScreenDefinition>, measureRequests: IList<MeasureRequest>): DisplayState => (new DisplayState({
    screenExpressions,
    screenDefinitions,
    measureRequests,
}));


export const MeasureRequest = buildValueClass('MeasureRequest', ['expr', 'resultHandler']);

export const newMeasureRequest = (expr: DisplayExpression, resultHandler: (width: number, height: number) => void): MeasureRequest => (new MeasureRequest({
    expr,
    resultHandler,
}));


export const ScreenDefinition = buildValueClass('ScreenDefinition', ['defName', 'expr', 'pos', 'key', 'isDragging']);

export const newScreenDefinition = (defName: string, expr: ?DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean): ScreenDefinition => (new ScreenDefinition({
    defName,
    expr,
    pos,
    key,
    isDragging,
}));


export const ScreenExpression = buildValueClass('ScreenExpression', ['expr', 'pos', 'key', 'isDragging', 'executeHandler']);

export const newScreenExpression = (expr: DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean, executeHandler: ?() => void): ScreenExpression => (new ScreenExpression({
    expr,
    pos,
    key,
    isDragging,
    executeHandler,
}));

export const DisplayLambda = buildUnionCaseClass('displayLambda', ['exprKey', 'shouldHighlight', 'varKey', 'emptyBodyKey', 'shouldHighlightEmptyBody', 'varName', 'body']);

export const newDisplayLambda = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varKey: ?LambdaVarKey, emptyBodyKey: ?EmptyBodyKey, shouldHighlightEmptyBody: boolean, varName: string, body: ?DisplayExpression): DisplayLambda => (new DisplayLambda({
    type: 'displayLambda',
    exprKey,
    shouldHighlight,
    varKey,
    emptyBodyKey,
    shouldHighlightEmptyBody,
    varName,
    body,
}));

export const DisplayFuncCall = buildUnionCaseClass('displayFuncCall', ['exprKey', 'shouldHighlight', 'func', 'arg']);

export const newDisplayFuncCall = (exprKey: ?ExpressionKey, shouldHighlight: boolean, func: DisplayExpression, arg: DisplayExpression): DisplayFuncCall => (new DisplayFuncCall({
    type: 'displayFuncCall',
    exprKey,
    shouldHighlight,
    func,
    arg,
}));

export const DisplayVariable = buildUnionCaseClass('displayVariable', ['exprKey', 'shouldHighlight', 'varName']);

export const newDisplayVariable = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varName: string): DisplayVariable => (new DisplayVariable({
    type: 'displayVariable',
    exprKey,
    shouldHighlight,
    varName,
}));

export const DisplayReference = buildUnionCaseClass('displayReference', ['exprKey', 'shouldHighlight', 'defName']);

export const newDisplayReference = (exprKey: ?ExpressionKey, shouldHighlight: boolean, defName: string): DisplayReference => (new DisplayReference({
    type: 'displayReference',
    exprKey,
    shouldHighlight,
    defName,
}));


export const CanvasPoint = buildValueClass('CanvasPoint', ['canvasX', 'canvasY']);

export const newCanvasPoint = (canvasX: number, canvasY: number): CanvasPoint => (new CanvasPoint({
    canvasX,
    canvasY,
}));


export const PointDifference = buildValueClass('PointDifference', ['dx', 'dy']);

export const newPointDifference = (dx: number, dy: number): PointDifference => (new PointDifference({
    dx,
    dy,
}));


export const ScreenPoint = buildValueClass('ScreenPoint', ['screenX', 'screenY']);

export const newScreenPoint = (screenX: number, screenY: number): ScreenPoint => (new ScreenPoint({
    screenX,
    screenY,
}));


export const ScreenRect = buildValueClass('ScreenRect', ['topLeft', 'bottomRight']);

export const newScreenRect = (topLeft: ScreenPoint, bottomRight: ScreenPoint): ScreenRect => (new ScreenRect({
    topLeft,
    bottomRight,
}));



export const ExprPath = buildValueClass('ExprPath', ['container', 'pathSteps']);

export const newExprPath = (container: ExprContainer, pathSteps: IList<PathComponent>): ExprPath => (new ExprPath({
    container,
    pathSteps,
}));

export const ExprIdContainer = buildUnionCaseClass('exprIdContainer', ['exprId']);

export const newExprIdContainer = (exprId: number): ExprIdContainer => (new ExprIdContainer({
    type: 'exprIdContainer',
    exprId,
}));

export const DefinitionContainer = buildUnionCaseClass('definitionContainer', ['defName']);

export const newDefinitionContainer = (defName: string): DefinitionContainer => (new DefinitionContainer({
    type: 'definitionContainer',
    defName,
}));

export const PickUpExpression = buildUnionCaseClass('pickUpExpression', ['exprId', 'offset', 'screenRect']);

export const newPickUpExpression = (exprId: number, offset: PointDifference, screenRect: ScreenRect): PickUpExpression => (new PickUpExpression({
    type: 'pickUpExpression',
    exprId,
    offset,
    screenRect,
}));

export const DecomposeExpression = buildUnionCaseClass('decomposeExpression', ['exprPath', 'offset', 'screenRect']);

export const newDecomposeExpression = (exprPath: ExprPath, offset: PointDifference, screenRect: ScreenRect): DecomposeExpression => (new DecomposeExpression({
    type: 'decomposeExpression',
    exprPath,
    offset,
    screenRect,
}));

export const CreateExpression = buildUnionCaseClass('createExpression', ['expr', 'offset', 'screenRect']);

export const newCreateExpression = (expr: UserExpression, offset: PointDifference, screenRect: ScreenRect): CreateExpression => (new CreateExpression({
    type: 'createExpression',
    expr,
    offset,
    screenRect,
}));

export const StartPan = buildUnionCaseClass('startPan', ['startPos']);

export const newStartPan = (startPos: ScreenPoint): StartPan => (new StartPan({
    type: 'startPan',
    startPos,
}));


export const DragData = buildValueClass('DragData', ['userExpr', 'grabOffset', 'screenRect']);

export const newDragData = (userExpr: UserExpression, grabOffset: PointDifference, screenRect: ScreenRect): DragData => (new DragData({
    userExpr,
    grabOffset,
    screenRect,
}));

export const AddToTopLevelResult = buildUnionCaseClass('addToTopLevelResult', ['expr', 'screenPos']);

export const newAddToTopLevelResult = (expr: UserExpression, screenPos: ScreenPoint): AddToTopLevelResult => (new AddToTopLevelResult({
    type: 'addToTopLevelResult',
    expr,
    screenPos,
}));

export const InsertAsBodyResult = buildUnionCaseClass('insertAsBodyResult', ['lambdaPath', 'expr']);

export const newInsertAsBodyResult = (lambdaPath: ExprPath, expr: UserExpression): InsertAsBodyResult => (new InsertAsBodyResult({
    type: 'insertAsBodyResult',
    lambdaPath,
    expr,
}));

export const InsertAsArgResult = buildUnionCaseClass('insertAsArgResult', ['path', 'expr']);

export const newInsertAsArgResult = (path: ExprPath, expr: UserExpression): InsertAsArgResult => (new InsertAsArgResult({
    type: 'insertAsArgResult',
    path,
    expr,
}));

export const RemoveResult = buildUnionCaseClass('removeResult', []);

export const newRemoveResult = (): RemoveResult => (new RemoveResult({
    type: 'removeResult',
}));

export const ExpressionKey = buildUnionCaseClass('expressionKey', ['exprPath']);

export const newExpressionKey = (exprPath: ExprPath): ExpressionKey => (new ExpressionKey({
    type: 'expressionKey',
    exprPath,
}));

export const EmptyBodyKey = buildUnionCaseClass('emptyBodyKey', ['lambdaPath']);

export const newEmptyBodyKey = (lambdaPath: ExprPath): EmptyBodyKey => (new EmptyBodyKey({
    type: 'emptyBodyKey',
    lambdaPath,
}));

export const LambdaVarKey = buildUnionCaseClass('lambdaVarKey', ['lambdaPath']);

export const newLambdaVarKey = (lambdaPath: ExprPath): LambdaVarKey => (new LambdaVarKey({
    type: 'lambdaVarKey',
    lambdaPath,
}));

export const DefinitionKey = buildUnionCaseClass('definitionKey', ['defName']);

export const newDefinitionKey = (defName: string): DefinitionKey => (new DefinitionKey({
    type: 'definitionKey',
    defName,
}));

