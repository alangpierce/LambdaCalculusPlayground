/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 *
 * @flow
 */
 
import * as Immutable from 'immutable'
 
class StateImpl extends Immutable.Record({
        canvasExpressions: undefined, nextExprId: undefined, canvasDefinitions: undefined, definitions: undefined, pendingResults: undefined, activeDrags: undefined, highlightedExprs: undefined, highlightedEmptyBodies: undefined}) {
    withCanvasExpressions(canvasExpressions) {
        return this.set('canvasExpressions', canvasExpressions)
    }
    withNextExprId(nextExprId) {
        return this.set('nextExprId', nextExprId)
    }
    withCanvasDefinitions(canvasDefinitions) {
        return this.set('canvasDefinitions', canvasDefinitions)
    }
    withDefinitions(definitions) {
        return this.set('definitions', definitions)
    }
    withPendingResults(pendingResults) {
        return this.set('pendingResults', pendingResults)
    }
    withActiveDrags(activeDrags) {
        return this.set('activeDrags', activeDrags)
    }
    withHighlightedExprs(highlightedExprs) {
        return this.set('highlightedExprs', highlightedExprs)
    }
    withHighlightedEmptyBodies(highlightedEmptyBodies) {
        return this.set('highlightedEmptyBodies', highlightedEmptyBodies)
    }
    updateCanvasExpressions(updater) {
        return this.set('canvasExpressions', updater(this.canvasExpressions))
    }
    updateNextExprId(updater) {
        return this.set('nextExprId', updater(this.nextExprId))
    }
    updateCanvasDefinitions(updater) {
        return this.set('canvasDefinitions', updater(this.canvasDefinitions))
    }
    updateDefinitions(updater) {
        return this.set('definitions', updater(this.definitions))
    }
    updatePendingResults(updater) {
        return this.set('pendingResults', updater(this.pendingResults))
    }
    updateActiveDrags(updater) {
        return this.set('activeDrags', updater(this.activeDrags))
    }
    updateHighlightedExprs(updater) {
        return this.set('highlightedExprs', updater(this.highlightedExprs))
    }
    updateHighlightedEmptyBodies(updater) {
        return this.set('highlightedEmptyBodies', updater(this.highlightedEmptyBodies))
    }
}

export type State = {
    canvasExpressions: Immutable.Map<number, CanvasExpression>,
    nextExprId: number,
    canvasDefinitions: Immutable.Map<string, CanvasPoint>,
    definitions: Immutable.Map<string, ?UserExpression>,
    pendingResults: Immutable.Map<number, PendingResult>,
    activeDrags: Immutable.Map<number, DragData>,
    highlightedExprs: Immutable.Set<ExprPath>,
    highlightedEmptyBodies: Immutable.Set<ExprPath>,
    withCanvasExpressions: (canvasExpressions: Immutable.Map<number, CanvasExpression>) => State,
    withNextExprId: (nextExprId: number) => State,
    withCanvasDefinitions: (canvasDefinitions: Immutable.Map<string, CanvasPoint>) => State,
    withDefinitions: (definitions: Immutable.Map<string, ?UserExpression>) => State,
    withPendingResults: (pendingResults: Immutable.Map<number, PendingResult>) => State,
    withActiveDrags: (activeDrags: Immutable.Map<number, DragData>) => State,
    withHighlightedExprs: (highlightedExprs: Immutable.Set<ExprPath>) => State,
    withHighlightedEmptyBodies: (highlightedEmptyBodies: Immutable.Set<ExprPath>) => State,
    updateCanvasExpressions: (updater: (canvasExpressions: Immutable.Map<number, CanvasExpression>) => Immutable.Map<number, CanvasExpression>) => State,
    updateNextExprId: (updater: (nextExprId: number) => number) => State,
    updateCanvasDefinitions: (updater: (canvasDefinitions: Immutable.Map<string, CanvasPoint>) => Immutable.Map<string, CanvasPoint>) => State,
    updateDefinitions: (updater: (definitions: Immutable.Map<string, ?UserExpression>) => Immutable.Map<string, ?UserExpression>) => State,
    updatePendingResults: (updater: (pendingResults: Immutable.Map<number, PendingResult>) => Immutable.Map<number, PendingResult>) => State,
    updateActiveDrags: (updater: (activeDrags: Immutable.Map<number, DragData>) => Immutable.Map<number, DragData>) => State,
    updateHighlightedExprs: (updater: (highlightedExprs: Immutable.Set<ExprPath>) => Immutable.Set<ExprPath>) => State,
    updateHighlightedEmptyBodies: (updater: (highlightedEmptyBodies: Immutable.Set<ExprPath>) => Immutable.Set<ExprPath>) => State,
    toJS: () => any,
};

export const newState = (canvasExpressions: Immutable.Map<number, CanvasExpression>, nextExprId: number, canvasDefinitions: Immutable.Map<string, CanvasPoint>, definitions: Immutable.Map<string, ?UserExpression>, pendingResults: Immutable.Map<number, PendingResult>, activeDrags: Immutable.Map<number, DragData>, highlightedExprs: Immutable.Set<ExprPath>, highlightedEmptyBodies: Immutable.Set<ExprPath>): State => (new StateImpl({
    canvasExpressions,
    nextExprId,
    canvasDefinitions,
    definitions,
    pendingResults,
    activeDrags,
    highlightedExprs,
    highlightedEmptyBodies,
}));

export type Reset = {
    type: 'reset',
};

export const newReset = (): Reset => ({
    type: 'reset',
});

export type AddExpression = {
    type: 'addExpression',
    canvasExpr: CanvasExpression,
};

export const newAddExpression = (canvasExpr: CanvasExpression): AddExpression => ({
    type: 'addExpression',
    canvasExpr,
});

export type PlaceDefinition = {
    type: 'placeDefinition',
    defName: string,
    screenPos: ScreenPoint,
};

export const newPlaceDefinition = (defName: string, screenPos: ScreenPoint): PlaceDefinition => ({
    type: 'placeDefinition',
    defName,
    screenPos,
});

export type MoveExpression = {
    type: 'moveExpression',
    exprId: number,
    pos: CanvasPoint,
};

export const newMoveExpression = (exprId: number, pos: CanvasPoint): MoveExpression => ({
    type: 'moveExpression',
    exprId,
    pos,
});

export type DecomposeExpressionAction = {
    type: 'decomposeExpressionAction',
    path: ExprPath,
    targetPos: CanvasPoint,
};

export const newDecomposeExpressionAction = (path: ExprPath, targetPos: CanvasPoint): DecomposeExpressionAction => ({
    type: 'decomposeExpressionAction',
    path,
    targetPos,
});

export type InsertAsArg = {
    type: 'insertAsArg',
    argExprId: number,
    path: ExprPath,
};

export const newInsertAsArg = (argExprId: number, path: ExprPath): InsertAsArg => ({
    type: 'insertAsArg',
    argExprId,
    path,
});

export type InsertAsBody = {
    type: 'insertAsBody',
    bodyExprId: number,
    path: ExprPath,
};

export const newInsertAsBody = (bodyExprId: number, path: ExprPath): InsertAsBody => ({
    type: 'insertAsBody',
    bodyExprId,
    path,
});

export type EvaluateExpression = {
    type: 'evaluateExpression',
    exprId: number,
};

export const newEvaluateExpression = (exprId: number): EvaluateExpression => ({
    type: 'evaluateExpression',
    exprId,
});

export type PlacePendingResult = {
    type: 'placePendingResult',
    exprId: number,
    width: number,
    height: number,
};

export const newPlacePendingResult = (exprId: number, width: number, height: number): PlacePendingResult => ({
    type: 'placePendingResult',
    exprId,
    width,
    height,
});

export type FingerDown = {
    type: 'fingerDown',
    fingerId: number,
    screenPos: ScreenPoint,
};

export const newFingerDown = (fingerId: number, screenPos: ScreenPoint): FingerDown => ({
    type: 'fingerDown',
    fingerId,
    screenPos,
});

export type FingerMove = {
    type: 'fingerMove',
    fingerId: number,
    screenPos: ScreenPoint,
};

export const newFingerMove = (fingerId: number, screenPos: ScreenPoint): FingerMove => ({
    type: 'fingerMove',
    fingerId,
    screenPos,
});

export type FingerUp = {
    type: 'fingerUp',
    fingerId: number,
    screenPos: ScreenPoint,
};

export const newFingerUp = (fingerId: number, screenPos: ScreenPoint): FingerUp => ({
    type: 'fingerUp',
    fingerId,
    screenPos,
});

export type Action = Reset | AddExpression | PlaceDefinition | MoveExpression | DecomposeExpressionAction | InsertAsArg | InsertAsBody | EvaluateExpression | PlacePendingResult | FingerDown | FingerMove | FingerUp;

export type ActionVisitor<T> = {
    reset: (reset: Reset) => T,
    addExpression: (addExpression: AddExpression) => T,
    placeDefinition: (placeDefinition: PlaceDefinition) => T,
    moveExpression: (moveExpression: MoveExpression) => T,
    decomposeExpressionAction: (decomposeExpressionAction: DecomposeExpressionAction) => T,
    insertAsArg: (insertAsArg: InsertAsArg) => T,
    insertAsBody: (insertAsBody: InsertAsBody) => T,
    evaluateExpression: (evaluateExpression: EvaluateExpression) => T,
    placePendingResult: (placePendingResult: PlacePendingResult) => T,
    fingerDown: (fingerDown: FingerDown) => T,
    fingerMove: (fingerMove: FingerMove) => T,
    fingerUp: (fingerUp: FingerUp) => T,
}

export const matchAction = function<T>(action: Action, visitor: ActionVisitor<T>): T {
    switch (action.type) {
        case 'reset':
            return visitor.reset(action);
        case 'addExpression':
            return visitor.addExpression(action);
        case 'placeDefinition':
            return visitor.placeDefinition(action);
        case 'moveExpression':
            return visitor.moveExpression(action);
        case 'decomposeExpressionAction':
            return visitor.decomposeExpressionAction(action);
        case 'insertAsArg':
            return visitor.insertAsArg(action);
        case 'insertAsBody':
            return visitor.insertAsBody(action);
        case 'evaluateExpression':
            return visitor.evaluateExpression(action);
        case 'placePendingResult':
            return visitor.placePendingResult(action);
        case 'fingerDown':
            return visitor.fingerDown(action);
        case 'fingerMove':
            return visitor.fingerMove(action);
        case 'fingerUp':
            return visitor.fingerUp(action);
        default:
            throw new Error('Unexpected type: ' + action.type);
    }
};

class LambdaImpl extends Immutable.Record({
        type: undefined, varName: undefined, body: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    withBody(body) {
        return this.set('body', body)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
    updateBody(updater) {
        return this.set('body', updater(this.body))
    }
}

export type Lambda = {
    type: 'lambda',
    varName: string,
    body: Expression,
    withVarName: (varName: string) => Lambda,
    withBody: (body: Expression) => Lambda,
    updateVarName: (updater: (varName: string) => string) => Lambda,
    updateBody: (updater: (body: Expression) => Expression) => Lambda,
    toJS: () => any,
};

export const newLambda = (varName: string, body: Expression): Lambda => (new LambdaImpl({
    type: 'lambda',
    varName,
    body,
}));

class FuncCallImpl extends Immutable.Record({
        type: undefined, func: undefined, arg: undefined}) {
    withFunc(func) {
        return this.set('func', func)
    }
    withArg(arg) {
        return this.set('arg', arg)
    }
    updateFunc(updater) {
        return this.set('func', updater(this.func))
    }
    updateArg(updater) {
        return this.set('arg', updater(this.arg))
    }
}

export type FuncCall = {
    type: 'funcCall',
    func: Expression,
    arg: Expression,
    withFunc: (func: Expression) => FuncCall,
    withArg: (arg: Expression) => FuncCall,
    updateFunc: (updater: (func: Expression) => Expression) => FuncCall,
    updateArg: (updater: (arg: Expression) => Expression) => FuncCall,
    toJS: () => any,
};

export const newFuncCall = (func: Expression, arg: Expression): FuncCall => (new FuncCallImpl({
    type: 'funcCall',
    func,
    arg,
}));

class VariableImpl extends Immutable.Record({
        type: undefined, varName: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
}

export type Variable = {
    type: 'variable',
    varName: string,
    withVarName: (varName: string) => Variable,
    updateVarName: (updater: (varName: string) => string) => Variable,
    toJS: () => any,
};

export const newVariable = (varName: string): Variable => (new VariableImpl({
    type: 'variable',
    varName,
}));

export type Expression = Lambda | FuncCall | Variable;

export type ExpressionVisitor<T> = {
    lambda: (lambda: Lambda) => T,
    funcCall: (funcCall: FuncCall) => T,
    variable: (variable: Variable) => T,
}

export const matchExpression = function<T>(expression: Expression, visitor: ExpressionVisitor<T>): T {
    switch (expression.type) {
        case 'lambda':
            return visitor.lambda(expression);
        case 'funcCall':
            return visitor.funcCall(expression);
        case 'variable':
            return visitor.variable(expression);
        default:
            throw new Error('Unexpected type: ' + expression.type);
    }
};

export type Slot = {
    isValue: boolean,
    expr: EvalExpression,
    originalVarName: string
};

export type VarMarker = number;

class EvalLambdaImpl extends Immutable.Record({
        type: undefined, varMarker: undefined, originalVarName: undefined, body: undefined}) {
    withVarMarker(varMarker) {
        return this.set('varMarker', varMarker)
    }
    withOriginalVarName(originalVarName) {
        return this.set('originalVarName', originalVarName)
    }
    withBody(body) {
        return this.set('body', body)
    }
    updateVarMarker(updater) {
        return this.set('varMarker', updater(this.varMarker))
    }
    updateOriginalVarName(updater) {
        return this.set('originalVarName', updater(this.originalVarName))
    }
    updateBody(updater) {
        return this.set('body', updater(this.body))
    }
}

export type EvalLambda = {
    type: 'evalLambda',
    varMarker: VarMarker,
    originalVarName: string,
    body: EvalExpression,
    withVarMarker: (varMarker: VarMarker) => EvalLambda,
    withOriginalVarName: (originalVarName: string) => EvalLambda,
    withBody: (body: EvalExpression) => EvalLambda,
    updateVarMarker: (updater: (varMarker: VarMarker) => VarMarker) => EvalLambda,
    updateOriginalVarName: (updater: (originalVarName: string) => string) => EvalLambda,
    updateBody: (updater: (body: EvalExpression) => EvalExpression) => EvalLambda,
    toJS: () => any,
};

export const newEvalLambda = (varMarker: VarMarker, originalVarName: string, body: EvalExpression): EvalLambda => (new EvalLambdaImpl({
    type: 'evalLambda',
    varMarker,
    originalVarName,
    body,
}));

class EvalFuncCallImpl extends Immutable.Record({
        type: undefined, func: undefined, arg: undefined}) {
    withFunc(func) {
        return this.set('func', func)
    }
    withArg(arg) {
        return this.set('arg', arg)
    }
    updateFunc(updater) {
        return this.set('func', updater(this.func))
    }
    updateArg(updater) {
        return this.set('arg', updater(this.arg))
    }
}

export type EvalFuncCall = {
    type: 'evalFuncCall',
    func: EvalExpression,
    arg: EvalExpression,
    withFunc: (func: EvalExpression) => EvalFuncCall,
    withArg: (arg: EvalExpression) => EvalFuncCall,
    updateFunc: (updater: (func: EvalExpression) => EvalExpression) => EvalFuncCall,
    updateArg: (updater: (arg: EvalExpression) => EvalExpression) => EvalFuncCall,
    toJS: () => any,
};

export const newEvalFuncCall = (func: EvalExpression, arg: EvalExpression): EvalFuncCall => (new EvalFuncCallImpl({
    type: 'evalFuncCall',
    func,
    arg,
}));

class EvalBoundVariableImpl extends Immutable.Record({
        type: undefined, slot: undefined}) {
    withSlot(slot) {
        return this.set('slot', slot)
    }
    updateSlot(updater) {
        return this.set('slot', updater(this.slot))
    }
}

export type EvalBoundVariable = {
    type: 'evalBoundVariable',
    slot: Slot,
    withSlot: (slot: Slot) => EvalBoundVariable,
    updateSlot: (updater: (slot: Slot) => Slot) => EvalBoundVariable,
    toJS: () => any,
};

export const newEvalBoundVariable = (slot: Slot): EvalBoundVariable => (new EvalBoundVariableImpl({
    type: 'evalBoundVariable',
    slot,
}));

class EvalUnboundVariableImpl extends Immutable.Record({
        type: undefined, varMarker: undefined, originalVarName: undefined}) {
    withVarMarker(varMarker) {
        return this.set('varMarker', varMarker)
    }
    withOriginalVarName(originalVarName) {
        return this.set('originalVarName', originalVarName)
    }
    updateVarMarker(updater) {
        return this.set('varMarker', updater(this.varMarker))
    }
    updateOriginalVarName(updater) {
        return this.set('originalVarName', updater(this.originalVarName))
    }
}

export type EvalUnboundVariable = {
    type: 'evalUnboundVariable',
    varMarker: VarMarker,
    originalVarName: string,
    withVarMarker: (varMarker: VarMarker) => EvalUnboundVariable,
    withOriginalVarName: (originalVarName: string) => EvalUnboundVariable,
    updateVarMarker: (updater: (varMarker: VarMarker) => VarMarker) => EvalUnboundVariable,
    updateOriginalVarName: (updater: (originalVarName: string) => string) => EvalUnboundVariable,
    toJS: () => any,
};

export const newEvalUnboundVariable = (varMarker: VarMarker, originalVarName: string): EvalUnboundVariable => (new EvalUnboundVariableImpl({
    type: 'evalUnboundVariable',
    varMarker,
    originalVarName,
}));

class EvalFreeVariableImpl extends Immutable.Record({
        type: undefined, varName: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
}

export type EvalFreeVariable = {
    type: 'evalFreeVariable',
    varName: string,
    withVarName: (varName: string) => EvalFreeVariable,
    updateVarName: (updater: (varName: string) => string) => EvalFreeVariable,
    toJS: () => any,
};

export const newEvalFreeVariable = (varName: string): EvalFreeVariable => (new EvalFreeVariableImpl({
    type: 'evalFreeVariable',
    varName,
}));

export type EvalExpression = EvalLambda | EvalFuncCall | EvalBoundVariable | EvalUnboundVariable | EvalFreeVariable;

export type EvalExpressionVisitor<T> = {
    evalLambda: (evalLambda: EvalLambda) => T,
    evalFuncCall: (evalFuncCall: EvalFuncCall) => T,
    evalBoundVariable: (evalBoundVariable: EvalBoundVariable) => T,
    evalUnboundVariable: (evalUnboundVariable: EvalUnboundVariable) => T,
    evalFreeVariable: (evalFreeVariable: EvalFreeVariable) => T,
}

export const matchEvalExpression = function<T>(evalExpression: EvalExpression, visitor: EvalExpressionVisitor<T>): T {
    switch (evalExpression.type) {
        case 'evalLambda':
            return visitor.evalLambda(evalExpression);
        case 'evalFuncCall':
            return visitor.evalFuncCall(evalExpression);
        case 'evalBoundVariable':
            return visitor.evalBoundVariable(evalExpression);
        case 'evalUnboundVariable':
            return visitor.evalUnboundVariable(evalExpression);
        case 'evalFreeVariable':
            return visitor.evalFreeVariable(evalExpression);
        default:
            throw new Error('Unexpected type: ' + evalExpression.type);
    }
};

class UserLambdaImpl extends Immutable.Record({
        type: undefined, varName: undefined, body: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    withBody(body) {
        return this.set('body', body)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
    updateBody(updater) {
        return this.set('body', updater(this.body))
    }
}

export type UserLambda = {
    type: 'userLambda',
    varName: string,
    body: ?UserExpression,
    withVarName: (varName: string) => UserLambda,
    withBody: (body: ?UserExpression) => UserLambda,
    updateVarName: (updater: (varName: string) => string) => UserLambda,
    updateBody: (updater: (body: ?UserExpression) => ?UserExpression) => UserLambda,
    toJS: () => any,
};

export const newUserLambda = (varName: string, body: ?UserExpression): UserLambda => (new UserLambdaImpl({
    type: 'userLambda',
    varName,
    body,
}));

class UserFuncCallImpl extends Immutable.Record({
        type: undefined, func: undefined, arg: undefined}) {
    withFunc(func) {
        return this.set('func', func)
    }
    withArg(arg) {
        return this.set('arg', arg)
    }
    updateFunc(updater) {
        return this.set('func', updater(this.func))
    }
    updateArg(updater) {
        return this.set('arg', updater(this.arg))
    }
}

export type UserFuncCall = {
    type: 'userFuncCall',
    func: UserExpression,
    arg: UserExpression,
    withFunc: (func: UserExpression) => UserFuncCall,
    withArg: (arg: UserExpression) => UserFuncCall,
    updateFunc: (updater: (func: UserExpression) => UserExpression) => UserFuncCall,
    updateArg: (updater: (arg: UserExpression) => UserExpression) => UserFuncCall,
    toJS: () => any,
};

export const newUserFuncCall = (func: UserExpression, arg: UserExpression): UserFuncCall => (new UserFuncCallImpl({
    type: 'userFuncCall',
    func,
    arg,
}));

class UserVariableImpl extends Immutable.Record({
        type: undefined, varName: undefined}) {
    withVarName(varName) {
        return this.set('varName', varName)
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
}

export type UserVariable = {
    type: 'userVariable',
    varName: string,
    withVarName: (varName: string) => UserVariable,
    updateVarName: (updater: (varName: string) => string) => UserVariable,
    toJS: () => any,
};

export const newUserVariable = (varName: string): UserVariable => (new UserVariableImpl({
    type: 'userVariable',
    varName,
}));

class UserReferenceImpl extends Immutable.Record({
        type: undefined, defName: undefined}) {
    withDefName(defName) {
        return this.set('defName', defName)
    }
    updateDefName(updater) {
        return this.set('defName', updater(this.defName))
    }
}

export type UserReference = {
    type: 'userReference',
    defName: string,
    withDefName: (defName: string) => UserReference,
    updateDefName: (updater: (defName: string) => string) => UserReference,
    toJS: () => any,
};

export const newUserReference = (defName: string): UserReference => (new UserReferenceImpl({
    type: 'userReference',
    defName,
}));

export type UserExpression = UserLambda | UserFuncCall | UserVariable | UserReference;

export type UserExpressionVisitor<T> = {
    userLambda: (userLambda: UserLambda) => T,
    userFuncCall: (userFuncCall: UserFuncCall) => T,
    userVariable: (userVariable: UserVariable) => T,
    userReference: (userReference: UserReference) => T,
}

export const matchUserExpression = function<T>(userExpression: UserExpression, visitor: UserExpressionVisitor<T>): T {
    switch (userExpression.type) {
        case 'userLambda':
            return visitor.userLambda(userExpression);
        case 'userFuncCall':
            return visitor.userFuncCall(userExpression);
        case 'userVariable':
            return visitor.userVariable(userExpression);
        case 'userReference':
            return visitor.userReference(userExpression);
        default:
            throw new Error('Unexpected type: ' + userExpression.type);
    }
};

class CanvasExpressionImpl extends Immutable.Record({
        expr: undefined, pos: undefined}) {
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withPos(pos) {
        return this.set('pos', pos)
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updatePos(updater) {
        return this.set('pos', updater(this.pos))
    }
}

export type CanvasExpression = {
    expr: UserExpression,
    pos: CanvasPoint,
    withExpr: (expr: UserExpression) => CanvasExpression,
    withPos: (pos: CanvasPoint) => CanvasExpression,
    updateExpr: (updater: (expr: UserExpression) => UserExpression) => CanvasExpression,
    updatePos: (updater: (pos: CanvasPoint) => CanvasPoint) => CanvasExpression,
    toJS: () => any,
};

export const newCanvasExpression = (expr: UserExpression, pos: CanvasPoint): CanvasExpression => (new CanvasExpressionImpl({
    expr,
    pos,
}));

class PendingResultImpl extends Immutable.Record({
        expr: undefined, sourceExprId: undefined}) {
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withSourceExprId(sourceExprId) {
        return this.set('sourceExprId', sourceExprId)
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updateSourceExprId(updater) {
        return this.set('sourceExprId', updater(this.sourceExprId))
    }
}

export type PendingResult = {
    expr: UserExpression,
    sourceExprId: number,
    withExpr: (expr: UserExpression) => PendingResult,
    withSourceExprId: (sourceExprId: number) => PendingResult,
    updateExpr: (updater: (expr: UserExpression) => UserExpression) => PendingResult,
    updateSourceExprId: (updater: (sourceExprId: number) => number) => PendingResult,
    toJS: () => any,
};

export const newPendingResult = (expr: UserExpression, sourceExprId: number): PendingResult => (new PendingResultImpl({
    expr,
    sourceExprId,
}));

class DisplayStateImpl extends Immutable.Record({
        screenExpressions: undefined, screenDefinitions: undefined, measureRequests: undefined}) {
    withScreenExpressions(screenExpressions) {
        return this.set('screenExpressions', screenExpressions)
    }
    withScreenDefinitions(screenDefinitions) {
        return this.set('screenDefinitions', screenDefinitions)
    }
    withMeasureRequests(measureRequests) {
        return this.set('measureRequests', measureRequests)
    }
    updateScreenExpressions(updater) {
        return this.set('screenExpressions', updater(this.screenExpressions))
    }
    updateScreenDefinitions(updater) {
        return this.set('screenDefinitions', updater(this.screenDefinitions))
    }
    updateMeasureRequests(updater) {
        return this.set('measureRequests', updater(this.measureRequests))
    }
}

export type DisplayState = {
    screenExpressions: Immutable.List<ScreenExpression>,
    screenDefinitions: Immutable.List<ScreenDefinition>,
    measureRequests: Immutable.List<MeasureRequest>,
    withScreenExpressions: (screenExpressions: Immutable.List<ScreenExpression>) => DisplayState,
    withScreenDefinitions: (screenDefinitions: Immutable.List<ScreenDefinition>) => DisplayState,
    withMeasureRequests: (measureRequests: Immutable.List<MeasureRequest>) => DisplayState,
    updateScreenExpressions: (updater: (screenExpressions: Immutable.List<ScreenExpression>) => Immutable.List<ScreenExpression>) => DisplayState,
    updateScreenDefinitions: (updater: (screenDefinitions: Immutable.List<ScreenDefinition>) => Immutable.List<ScreenDefinition>) => DisplayState,
    updateMeasureRequests: (updater: (measureRequests: Immutable.List<MeasureRequest>) => Immutable.List<MeasureRequest>) => DisplayState,
    toJS: () => any,
};

export const newDisplayState = (screenExpressions: Immutable.List<ScreenExpression>, screenDefinitions: Immutable.List<ScreenDefinition>, measureRequests: Immutable.List<MeasureRequest>): DisplayState => (new DisplayStateImpl({
    screenExpressions,
    screenDefinitions,
    measureRequests,
}));

class MeasureRequestImpl extends Immutable.Record({
        expr: undefined, resultHandler: undefined}) {
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withResultHandler(resultHandler) {
        return this.set('resultHandler', resultHandler)
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updateResultHandler(updater) {
        return this.set('resultHandler', updater(this.resultHandler))
    }
}

export type MeasureRequest = {
    expr: DisplayExpression,
    resultHandler: (width: number, height: number) => void,
    withExpr: (expr: DisplayExpression) => MeasureRequest,
    withResultHandler: (resultHandler: (width: number, height: number) => void) => MeasureRequest,
    updateExpr: (updater: (expr: DisplayExpression) => DisplayExpression) => MeasureRequest,
    updateResultHandler: (updater: (resultHandler: (width: number, height: number) => void) => (width: number, height: number) => void) => MeasureRequest,
    toJS: () => any,
};

export const newMeasureRequest = (expr: DisplayExpression, resultHandler: (width: number, height: number) => void): MeasureRequest => (new MeasureRequestImpl({
    expr,
    resultHandler,
}));

class ScreenDefinitionImpl extends Immutable.Record({
        defName: undefined, expr: undefined, pos: undefined, key: undefined, isDragging: undefined}) {
    withDefName(defName) {
        return this.set('defName', defName)
    }
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withPos(pos) {
        return this.set('pos', pos)
    }
    withKey(key) {
        return this.set('key', key)
    }
    withIsDragging(isDragging) {
        return this.set('isDragging', isDragging)
    }
    updateDefName(updater) {
        return this.set('defName', updater(this.defName))
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updatePos(updater) {
        return this.set('pos', updater(this.pos))
    }
    updateKey(updater) {
        return this.set('key', updater(this.key))
    }
    updateIsDragging(updater) {
        return this.set('isDragging', updater(this.isDragging))
    }
}

export type ScreenDefinition = {
    defName: string,
    expr: ?DisplayExpression,
    pos: ScreenPoint,
    key: string,
    isDragging: boolean,
    withDefName: (defName: string) => ScreenDefinition,
    withExpr: (expr: ?DisplayExpression) => ScreenDefinition,
    withPos: (pos: ScreenPoint) => ScreenDefinition,
    withKey: (key: string) => ScreenDefinition,
    withIsDragging: (isDragging: boolean) => ScreenDefinition,
    updateDefName: (updater: (defName: string) => string) => ScreenDefinition,
    updateExpr: (updater: (expr: ?DisplayExpression) => ?DisplayExpression) => ScreenDefinition,
    updatePos: (updater: (pos: ScreenPoint) => ScreenPoint) => ScreenDefinition,
    updateKey: (updater: (key: string) => string) => ScreenDefinition,
    updateIsDragging: (updater: (isDragging: boolean) => boolean) => ScreenDefinition,
    toJS: () => any,
};

export const newScreenDefinition = (defName: string, expr: ?DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean): ScreenDefinition => (new ScreenDefinitionImpl({
    defName,
    expr,
    pos,
    key,
    isDragging,
}));

class ScreenExpressionImpl extends Immutable.Record({
        expr: undefined, pos: undefined, key: undefined, isDragging: undefined, executeHandler: undefined}) {
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withPos(pos) {
        return this.set('pos', pos)
    }
    withKey(key) {
        return this.set('key', key)
    }
    withIsDragging(isDragging) {
        return this.set('isDragging', isDragging)
    }
    withExecuteHandler(executeHandler) {
        return this.set('executeHandler', executeHandler)
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updatePos(updater) {
        return this.set('pos', updater(this.pos))
    }
    updateKey(updater) {
        return this.set('key', updater(this.key))
    }
    updateIsDragging(updater) {
        return this.set('isDragging', updater(this.isDragging))
    }
    updateExecuteHandler(updater) {
        return this.set('executeHandler', updater(this.executeHandler))
    }
}

export type ScreenExpression = {
    expr: DisplayExpression,
    pos: ScreenPoint,
    key: string,
    isDragging: boolean,
    executeHandler: ?() => void,
    withExpr: (expr: DisplayExpression) => ScreenExpression,
    withPos: (pos: ScreenPoint) => ScreenExpression,
    withKey: (key: string) => ScreenExpression,
    withIsDragging: (isDragging: boolean) => ScreenExpression,
    withExecuteHandler: (executeHandler: ?() => void) => ScreenExpression,
    updateExpr: (updater: (expr: DisplayExpression) => DisplayExpression) => ScreenExpression,
    updatePos: (updater: (pos: ScreenPoint) => ScreenPoint) => ScreenExpression,
    updateKey: (updater: (key: string) => string) => ScreenExpression,
    updateIsDragging: (updater: (isDragging: boolean) => boolean) => ScreenExpression,
    updateExecuteHandler: (updater: (executeHandler: ?() => void) => ?() => void) => ScreenExpression,
    toJS: () => any,
};

export const newScreenExpression = (expr: DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean, executeHandler: ?() => void): ScreenExpression => (new ScreenExpressionImpl({
    expr,
    pos,
    key,
    isDragging,
    executeHandler,
}));

class DisplayLambdaImpl extends Immutable.Record({
        type: undefined, exprKey: undefined, shouldHighlight: undefined, varKey: undefined, emptyBodyKey: undefined, shouldHighlightEmptyBody: undefined, varName: undefined, body: undefined}) {
    withExprKey(exprKey) {
        return this.set('exprKey', exprKey)
    }
    withShouldHighlight(shouldHighlight) {
        return this.set('shouldHighlight', shouldHighlight)
    }
    withVarKey(varKey) {
        return this.set('varKey', varKey)
    }
    withEmptyBodyKey(emptyBodyKey) {
        return this.set('emptyBodyKey', emptyBodyKey)
    }
    withShouldHighlightEmptyBody(shouldHighlightEmptyBody) {
        return this.set('shouldHighlightEmptyBody', shouldHighlightEmptyBody)
    }
    withVarName(varName) {
        return this.set('varName', varName)
    }
    withBody(body) {
        return this.set('body', body)
    }
    updateExprKey(updater) {
        return this.set('exprKey', updater(this.exprKey))
    }
    updateShouldHighlight(updater) {
        return this.set('shouldHighlight', updater(this.shouldHighlight))
    }
    updateVarKey(updater) {
        return this.set('varKey', updater(this.varKey))
    }
    updateEmptyBodyKey(updater) {
        return this.set('emptyBodyKey', updater(this.emptyBodyKey))
    }
    updateShouldHighlightEmptyBody(updater) {
        return this.set('shouldHighlightEmptyBody', updater(this.shouldHighlightEmptyBody))
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
    updateBody(updater) {
        return this.set('body', updater(this.body))
    }
}

export type DisplayLambda = {
    type: 'displayLambda',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    varKey: ?LambdaVarKey,
    emptyBodyKey: ?EmptyBodyKey,
    shouldHighlightEmptyBody: boolean,
    varName: string,
    body: ?DisplayExpression,
    withExprKey: (exprKey: ?ExpressionKey) => DisplayLambda,
    withShouldHighlight: (shouldHighlight: boolean) => DisplayLambda,
    withVarKey: (varKey: ?LambdaVarKey) => DisplayLambda,
    withEmptyBodyKey: (emptyBodyKey: ?EmptyBodyKey) => DisplayLambda,
    withShouldHighlightEmptyBody: (shouldHighlightEmptyBody: boolean) => DisplayLambda,
    withVarName: (varName: string) => DisplayLambda,
    withBody: (body: ?DisplayExpression) => DisplayLambda,
    updateExprKey: (updater: (exprKey: ?ExpressionKey) => ?ExpressionKey) => DisplayLambda,
    updateShouldHighlight: (updater: (shouldHighlight: boolean) => boolean) => DisplayLambda,
    updateVarKey: (updater: (varKey: ?LambdaVarKey) => ?LambdaVarKey) => DisplayLambda,
    updateEmptyBodyKey: (updater: (emptyBodyKey: ?EmptyBodyKey) => ?EmptyBodyKey) => DisplayLambda,
    updateShouldHighlightEmptyBody: (updater: (shouldHighlightEmptyBody: boolean) => boolean) => DisplayLambda,
    updateVarName: (updater: (varName: string) => string) => DisplayLambda,
    updateBody: (updater: (body: ?DisplayExpression) => ?DisplayExpression) => DisplayLambda,
    toJS: () => any,
};

export const newDisplayLambda = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varKey: ?LambdaVarKey, emptyBodyKey: ?EmptyBodyKey, shouldHighlightEmptyBody: boolean, varName: string, body: ?DisplayExpression): DisplayLambda => (new DisplayLambdaImpl({
    type: 'displayLambda',
    exprKey,
    shouldHighlight,
    varKey,
    emptyBodyKey,
    shouldHighlightEmptyBody,
    varName,
    body,
}));

class DisplayFuncCallImpl extends Immutable.Record({
        type: undefined, exprKey: undefined, shouldHighlight: undefined, func: undefined, arg: undefined}) {
    withExprKey(exprKey) {
        return this.set('exprKey', exprKey)
    }
    withShouldHighlight(shouldHighlight) {
        return this.set('shouldHighlight', shouldHighlight)
    }
    withFunc(func) {
        return this.set('func', func)
    }
    withArg(arg) {
        return this.set('arg', arg)
    }
    updateExprKey(updater) {
        return this.set('exprKey', updater(this.exprKey))
    }
    updateShouldHighlight(updater) {
        return this.set('shouldHighlight', updater(this.shouldHighlight))
    }
    updateFunc(updater) {
        return this.set('func', updater(this.func))
    }
    updateArg(updater) {
        return this.set('arg', updater(this.arg))
    }
}

export type DisplayFuncCall = {
    type: 'displayFuncCall',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    func: DisplayExpression,
    arg: DisplayExpression,
    withExprKey: (exprKey: ?ExpressionKey) => DisplayFuncCall,
    withShouldHighlight: (shouldHighlight: boolean) => DisplayFuncCall,
    withFunc: (func: DisplayExpression) => DisplayFuncCall,
    withArg: (arg: DisplayExpression) => DisplayFuncCall,
    updateExprKey: (updater: (exprKey: ?ExpressionKey) => ?ExpressionKey) => DisplayFuncCall,
    updateShouldHighlight: (updater: (shouldHighlight: boolean) => boolean) => DisplayFuncCall,
    updateFunc: (updater: (func: DisplayExpression) => DisplayExpression) => DisplayFuncCall,
    updateArg: (updater: (arg: DisplayExpression) => DisplayExpression) => DisplayFuncCall,
    toJS: () => any,
};

export const newDisplayFuncCall = (exprKey: ?ExpressionKey, shouldHighlight: boolean, func: DisplayExpression, arg: DisplayExpression): DisplayFuncCall => (new DisplayFuncCallImpl({
    type: 'displayFuncCall',
    exprKey,
    shouldHighlight,
    func,
    arg,
}));

class DisplayVariableImpl extends Immutable.Record({
        type: undefined, exprKey: undefined, shouldHighlight: undefined, varName: undefined}) {
    withExprKey(exprKey) {
        return this.set('exprKey', exprKey)
    }
    withShouldHighlight(shouldHighlight) {
        return this.set('shouldHighlight', shouldHighlight)
    }
    withVarName(varName) {
        return this.set('varName', varName)
    }
    updateExprKey(updater) {
        return this.set('exprKey', updater(this.exprKey))
    }
    updateShouldHighlight(updater) {
        return this.set('shouldHighlight', updater(this.shouldHighlight))
    }
    updateVarName(updater) {
        return this.set('varName', updater(this.varName))
    }
}

export type DisplayVariable = {
    type: 'displayVariable',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    varName: string,
    withExprKey: (exprKey: ?ExpressionKey) => DisplayVariable,
    withShouldHighlight: (shouldHighlight: boolean) => DisplayVariable,
    withVarName: (varName: string) => DisplayVariable,
    updateExprKey: (updater: (exprKey: ?ExpressionKey) => ?ExpressionKey) => DisplayVariable,
    updateShouldHighlight: (updater: (shouldHighlight: boolean) => boolean) => DisplayVariable,
    updateVarName: (updater: (varName: string) => string) => DisplayVariable,
    toJS: () => any,
};

export const newDisplayVariable = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varName: string): DisplayVariable => (new DisplayVariableImpl({
    type: 'displayVariable',
    exprKey,
    shouldHighlight,
    varName,
}));

class DisplayReferenceImpl extends Immutable.Record({
        type: undefined, exprKey: undefined, shouldHighlight: undefined, defName: undefined}) {
    withExprKey(exprKey) {
        return this.set('exprKey', exprKey)
    }
    withShouldHighlight(shouldHighlight) {
        return this.set('shouldHighlight', shouldHighlight)
    }
    withDefName(defName) {
        return this.set('defName', defName)
    }
    updateExprKey(updater) {
        return this.set('exprKey', updater(this.exprKey))
    }
    updateShouldHighlight(updater) {
        return this.set('shouldHighlight', updater(this.shouldHighlight))
    }
    updateDefName(updater) {
        return this.set('defName', updater(this.defName))
    }
}

export type DisplayReference = {
    type: 'displayReference',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    defName: string,
    withExprKey: (exprKey: ?ExpressionKey) => DisplayReference,
    withShouldHighlight: (shouldHighlight: boolean) => DisplayReference,
    withDefName: (defName: string) => DisplayReference,
    updateExprKey: (updater: (exprKey: ?ExpressionKey) => ?ExpressionKey) => DisplayReference,
    updateShouldHighlight: (updater: (shouldHighlight: boolean) => boolean) => DisplayReference,
    updateDefName: (updater: (defName: string) => string) => DisplayReference,
    toJS: () => any,
};

export const newDisplayReference = (exprKey: ?ExpressionKey, shouldHighlight: boolean, defName: string): DisplayReference => (new DisplayReferenceImpl({
    type: 'displayReference',
    exprKey,
    shouldHighlight,
    defName,
}));

export type DisplayExpression = DisplayLambda | DisplayFuncCall | DisplayVariable | DisplayReference;

export type DisplayExpressionVisitor<T> = {
    displayLambda: (displayLambda: DisplayLambda) => T,
    displayFuncCall: (displayFuncCall: DisplayFuncCall) => T,
    displayVariable: (displayVariable: DisplayVariable) => T,
    displayReference: (displayReference: DisplayReference) => T,
}

export const matchDisplayExpression = function<T>(displayExpression: DisplayExpression, visitor: DisplayExpressionVisitor<T>): T {
    switch (displayExpression.type) {
        case 'displayLambda':
            return visitor.displayLambda(displayExpression);
        case 'displayFuncCall':
            return visitor.displayFuncCall(displayExpression);
        case 'displayVariable':
            return visitor.displayVariable(displayExpression);
        case 'displayReference':
            return visitor.displayReference(displayExpression);
        default:
            throw new Error('Unexpected type: ' + displayExpression.type);
    }
};

class CanvasPointImpl extends Immutable.Record({
        canvasX: undefined, canvasY: undefined}) {
    withCanvasX(canvasX) {
        return this.set('canvasX', canvasX)
    }
    withCanvasY(canvasY) {
        return this.set('canvasY', canvasY)
    }
    updateCanvasX(updater) {
        return this.set('canvasX', updater(this.canvasX))
    }
    updateCanvasY(updater) {
        return this.set('canvasY', updater(this.canvasY))
    }
}

export type CanvasPoint = {
    canvasX: number,
    canvasY: number,
    withCanvasX: (canvasX: number) => CanvasPoint,
    withCanvasY: (canvasY: number) => CanvasPoint,
    updateCanvasX: (updater: (canvasX: number) => number) => CanvasPoint,
    updateCanvasY: (updater: (canvasY: number) => number) => CanvasPoint,
    toJS: () => any,
};

export const newCanvasPoint = (canvasX: number, canvasY: number): CanvasPoint => (new CanvasPointImpl({
    canvasX,
    canvasY,
}));

class PointDifferenceImpl extends Immutable.Record({
        dx: undefined, dy: undefined}) {
    withDx(dx) {
        return this.set('dx', dx)
    }
    withDy(dy) {
        return this.set('dy', dy)
    }
    updateDx(updater) {
        return this.set('dx', updater(this.dx))
    }
    updateDy(updater) {
        return this.set('dy', updater(this.dy))
    }
}

export type PointDifference = {
    dx: number,
    dy: number,
    withDx: (dx: number) => PointDifference,
    withDy: (dy: number) => PointDifference,
    updateDx: (updater: (dx: number) => number) => PointDifference,
    updateDy: (updater: (dy: number) => number) => PointDifference,
    toJS: () => any,
};

export const newPointDifference = (dx: number, dy: number): PointDifference => (new PointDifferenceImpl({
    dx,
    dy,
}));

class ScreenPointImpl extends Immutable.Record({
        screenX: undefined, screenY: undefined}) {
    withScreenX(screenX) {
        return this.set('screenX', screenX)
    }
    withScreenY(screenY) {
        return this.set('screenY', screenY)
    }
    updateScreenX(updater) {
        return this.set('screenX', updater(this.screenX))
    }
    updateScreenY(updater) {
        return this.set('screenY', updater(this.screenY))
    }
}

export type ScreenPoint = {
    screenX: number,
    screenY: number,
    withScreenX: (screenX: number) => ScreenPoint,
    withScreenY: (screenY: number) => ScreenPoint,
    updateScreenX: (updater: (screenX: number) => number) => ScreenPoint,
    updateScreenY: (updater: (screenY: number) => number) => ScreenPoint,
    toJS: () => any,
};

export const newScreenPoint = (screenX: number, screenY: number): ScreenPoint => (new ScreenPointImpl({
    screenX,
    screenY,
}));

class ScreenRectImpl extends Immutable.Record({
        topLeft: undefined, bottomRight: undefined}) {
    withTopLeft(topLeft) {
        return this.set('topLeft', topLeft)
    }
    withBottomRight(bottomRight) {
        return this.set('bottomRight', bottomRight)
    }
    updateTopLeft(updater) {
        return this.set('topLeft', updater(this.topLeft))
    }
    updateBottomRight(updater) {
        return this.set('bottomRight', updater(this.bottomRight))
    }
}

export type ScreenRect = {
    topLeft: ScreenPoint,
    bottomRight: ScreenPoint,
    withTopLeft: (topLeft: ScreenPoint) => ScreenRect,
    withBottomRight: (bottomRight: ScreenPoint) => ScreenRect,
    updateTopLeft: (updater: (topLeft: ScreenPoint) => ScreenPoint) => ScreenRect,
    updateBottomRight: (updater: (bottomRight: ScreenPoint) => ScreenPoint) => ScreenRect,
    toJS: () => any,
};

export const newScreenRect = (topLeft: ScreenPoint, bottomRight: ScreenPoint): ScreenRect => (new ScreenRectImpl({
    topLeft,
    bottomRight,
}));

export type PathComponent = 'func' | 'arg' | 'body';

class ExprPathImpl extends Immutable.Record({
        exprId: undefined, pathSteps: undefined}) {
    withExprId(exprId) {
        return this.set('exprId', exprId)
    }
    withPathSteps(pathSteps) {
        return this.set('pathSteps', pathSteps)
    }
    updateExprId(updater) {
        return this.set('exprId', updater(this.exprId))
    }
    updatePathSteps(updater) {
        return this.set('pathSteps', updater(this.pathSteps))
    }
}

export type ExprPath = {
    exprId: number,
    pathSteps: Immutable.List<PathComponent>,
    withExprId: (exprId: number) => ExprPath,
    withPathSteps: (pathSteps: Immutable.List<PathComponent>) => ExprPath,
    updateExprId: (updater: (exprId: number) => number) => ExprPath,
    updatePathSteps: (updater: (pathSteps: Immutable.List<PathComponent>) => Immutable.List<PathComponent>) => ExprPath,
    toJS: () => any,
};

export const newExprPath = (exprId: number, pathSteps: Immutable.List<PathComponent>): ExprPath => (new ExprPathImpl({
    exprId,
    pathSteps,
}));

class PickUpExpressionImpl extends Immutable.Record({
        type: undefined, exprId: undefined, offset: undefined, screenRect: undefined}) {
    withExprId(exprId) {
        return this.set('exprId', exprId)
    }
    withOffset(offset) {
        return this.set('offset', offset)
    }
    withScreenRect(screenRect) {
        return this.set('screenRect', screenRect)
    }
    updateExprId(updater) {
        return this.set('exprId', updater(this.exprId))
    }
    updateOffset(updater) {
        return this.set('offset', updater(this.offset))
    }
    updateScreenRect(updater) {
        return this.set('screenRect', updater(this.screenRect))
    }
}

export type PickUpExpression = {
    type: 'pickUpExpression',
    exprId: number,
    offset: PointDifference,
    screenRect: ScreenRect,
    withExprId: (exprId: number) => PickUpExpression,
    withOffset: (offset: PointDifference) => PickUpExpression,
    withScreenRect: (screenRect: ScreenRect) => PickUpExpression,
    updateExprId: (updater: (exprId: number) => number) => PickUpExpression,
    updateOffset: (updater: (offset: PointDifference) => PointDifference) => PickUpExpression,
    updateScreenRect: (updater: (screenRect: ScreenRect) => ScreenRect) => PickUpExpression,
    toJS: () => any,
};

export const newPickUpExpression = (exprId: number, offset: PointDifference, screenRect: ScreenRect): PickUpExpression => (new PickUpExpressionImpl({
    type: 'pickUpExpression',
    exprId,
    offset,
    screenRect,
}));

class DecomposeExpressionImpl extends Immutable.Record({
        type: undefined, exprPath: undefined, offset: undefined, screenRect: undefined}) {
    withExprPath(exprPath) {
        return this.set('exprPath', exprPath)
    }
    withOffset(offset) {
        return this.set('offset', offset)
    }
    withScreenRect(screenRect) {
        return this.set('screenRect', screenRect)
    }
    updateExprPath(updater) {
        return this.set('exprPath', updater(this.exprPath))
    }
    updateOffset(updater) {
        return this.set('offset', updater(this.offset))
    }
    updateScreenRect(updater) {
        return this.set('screenRect', updater(this.screenRect))
    }
}

export type DecomposeExpression = {
    type: 'decomposeExpression',
    exprPath: ExprPath,
    offset: PointDifference,
    screenRect: ScreenRect,
    withExprPath: (exprPath: ExprPath) => DecomposeExpression,
    withOffset: (offset: PointDifference) => DecomposeExpression,
    withScreenRect: (screenRect: ScreenRect) => DecomposeExpression,
    updateExprPath: (updater: (exprPath: ExprPath) => ExprPath) => DecomposeExpression,
    updateOffset: (updater: (offset: PointDifference) => PointDifference) => DecomposeExpression,
    updateScreenRect: (updater: (screenRect: ScreenRect) => ScreenRect) => DecomposeExpression,
    toJS: () => any,
};

export const newDecomposeExpression = (exprPath: ExprPath, offset: PointDifference, screenRect: ScreenRect): DecomposeExpression => (new DecomposeExpressionImpl({
    type: 'decomposeExpression',
    exprPath,
    offset,
    screenRect,
}));

class CreateExpressionImpl extends Immutable.Record({
        type: undefined, expr: undefined, offset: undefined, screenRect: undefined}) {
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withOffset(offset) {
        return this.set('offset', offset)
    }
    withScreenRect(screenRect) {
        return this.set('screenRect', screenRect)
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updateOffset(updater) {
        return this.set('offset', updater(this.offset))
    }
    updateScreenRect(updater) {
        return this.set('screenRect', updater(this.screenRect))
    }
}

export type CreateExpression = {
    type: 'createExpression',
    expr: UserExpression,
    offset: PointDifference,
    screenRect: ScreenRect,
    withExpr: (expr: UserExpression) => CreateExpression,
    withOffset: (offset: PointDifference) => CreateExpression,
    withScreenRect: (screenRect: ScreenRect) => CreateExpression,
    updateExpr: (updater: (expr: UserExpression) => UserExpression) => CreateExpression,
    updateOffset: (updater: (offset: PointDifference) => PointDifference) => CreateExpression,
    updateScreenRect: (updater: (screenRect: ScreenRect) => ScreenRect) => CreateExpression,
    toJS: () => any,
};

export const newCreateExpression = (expr: UserExpression, offset: PointDifference, screenRect: ScreenRect): CreateExpression => (new CreateExpressionImpl({
    type: 'createExpression',
    expr,
    offset,
    screenRect,
}));

class StartPanImpl extends Immutable.Record({
        type: undefined, startPos: undefined}) {
    withStartPos(startPos) {
        return this.set('startPos', startPos)
    }
    updateStartPos(updater) {
        return this.set('startPos', updater(this.startPos))
    }
}

export type StartPan = {
    type: 'startPan',
    startPos: ScreenPoint,
    withStartPos: (startPos: ScreenPoint) => StartPan,
    updateStartPos: (updater: (startPos: ScreenPoint) => ScreenPoint) => StartPan,
    toJS: () => any,
};

export const newStartPan = (startPos: ScreenPoint): StartPan => (new StartPanImpl({
    type: 'startPan',
    startPos,
}));

export type DragResult = PickUpExpression | DecomposeExpression | CreateExpression | StartPan;

export type DragResultVisitor<T> = {
    pickUpExpression: (pickUpExpression: PickUpExpression) => T,
    decomposeExpression: (decomposeExpression: DecomposeExpression) => T,
    createExpression: (createExpression: CreateExpression) => T,
    startPan: (startPan: StartPan) => T,
}

export const matchDragResult = function<T>(dragResult: DragResult, visitor: DragResultVisitor<T>): T {
    switch (dragResult.type) {
        case 'pickUpExpression':
            return visitor.pickUpExpression(dragResult);
        case 'decomposeExpression':
            return visitor.decomposeExpression(dragResult);
        case 'createExpression':
            return visitor.createExpression(dragResult);
        case 'startPan':
            return visitor.startPan(dragResult);
        default:
            throw new Error('Unexpected type: ' + dragResult.type);
    }
};

class DragDataImpl extends Immutable.Record({
        userExpr: undefined, grabOffset: undefined, screenRect: undefined}) {
    withUserExpr(userExpr) {
        return this.set('userExpr', userExpr)
    }
    withGrabOffset(grabOffset) {
        return this.set('grabOffset', grabOffset)
    }
    withScreenRect(screenRect) {
        return this.set('screenRect', screenRect)
    }
    updateUserExpr(updater) {
        return this.set('userExpr', updater(this.userExpr))
    }
    updateGrabOffset(updater) {
        return this.set('grabOffset', updater(this.grabOffset))
    }
    updateScreenRect(updater) {
        return this.set('screenRect', updater(this.screenRect))
    }
}

export type DragData = {
    userExpr: UserExpression,
    grabOffset: PointDifference,
    screenRect: ScreenRect,
    withUserExpr: (userExpr: UserExpression) => DragData,
    withGrabOffset: (grabOffset: PointDifference) => DragData,
    withScreenRect: (screenRect: ScreenRect) => DragData,
    updateUserExpr: (updater: (userExpr: UserExpression) => UserExpression) => DragData,
    updateGrabOffset: (updater: (grabOffset: PointDifference) => PointDifference) => DragData,
    updateScreenRect: (updater: (screenRect: ScreenRect) => ScreenRect) => DragData,
    toJS: () => any,
};

export const newDragData = (userExpr: UserExpression, grabOffset: PointDifference, screenRect: ScreenRect): DragData => (new DragDataImpl({
    userExpr,
    grabOffset,
    screenRect,
}));

class AddToTopLevelResultImpl extends Immutable.Record({
        type: undefined, expr: undefined, screenPos: undefined}) {
    withExpr(expr) {
        return this.set('expr', expr)
    }
    withScreenPos(screenPos) {
        return this.set('screenPos', screenPos)
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
    updateScreenPos(updater) {
        return this.set('screenPos', updater(this.screenPos))
    }
}

export type AddToTopLevelResult = {
    type: 'addToTopLevelResult',
    expr: UserExpression,
    screenPos: ScreenPoint,
    withExpr: (expr: UserExpression) => AddToTopLevelResult,
    withScreenPos: (screenPos: ScreenPoint) => AddToTopLevelResult,
    updateExpr: (updater: (expr: UserExpression) => UserExpression) => AddToTopLevelResult,
    updateScreenPos: (updater: (screenPos: ScreenPoint) => ScreenPoint) => AddToTopLevelResult,
    toJS: () => any,
};

export const newAddToTopLevelResult = (expr: UserExpression, screenPos: ScreenPoint): AddToTopLevelResult => (new AddToTopLevelResultImpl({
    type: 'addToTopLevelResult',
    expr,
    screenPos,
}));

class InsertAsBodyResultImpl extends Immutable.Record({
        type: undefined, lambdaPath: undefined, expr: undefined}) {
    withLambdaPath(lambdaPath) {
        return this.set('lambdaPath', lambdaPath)
    }
    withExpr(expr) {
        return this.set('expr', expr)
    }
    updateLambdaPath(updater) {
        return this.set('lambdaPath', updater(this.lambdaPath))
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
}

export type InsertAsBodyResult = {
    type: 'insertAsBodyResult',
    lambdaPath: ExprPath,
    expr: UserExpression,
    withLambdaPath: (lambdaPath: ExprPath) => InsertAsBodyResult,
    withExpr: (expr: UserExpression) => InsertAsBodyResult,
    updateLambdaPath: (updater: (lambdaPath: ExprPath) => ExprPath) => InsertAsBodyResult,
    updateExpr: (updater: (expr: UserExpression) => UserExpression) => InsertAsBodyResult,
    toJS: () => any,
};

export const newInsertAsBodyResult = (lambdaPath: ExprPath, expr: UserExpression): InsertAsBodyResult => (new InsertAsBodyResultImpl({
    type: 'insertAsBodyResult',
    lambdaPath,
    expr,
}));

class InsertAsArgResultImpl extends Immutable.Record({
        type: undefined, path: undefined, expr: undefined}) {
    withPath(path) {
        return this.set('path', path)
    }
    withExpr(expr) {
        return this.set('expr', expr)
    }
    updatePath(updater) {
        return this.set('path', updater(this.path))
    }
    updateExpr(updater) {
        return this.set('expr', updater(this.expr))
    }
}

export type InsertAsArgResult = {
    type: 'insertAsArgResult',
    path: ExprPath,
    expr: UserExpression,
    withPath: (path: ExprPath) => InsertAsArgResult,
    withExpr: (expr: UserExpression) => InsertAsArgResult,
    updatePath: (updater: (path: ExprPath) => ExprPath) => InsertAsArgResult,
    updateExpr: (updater: (expr: UserExpression) => UserExpression) => InsertAsArgResult,
    toJS: () => any,
};

export const newInsertAsArgResult = (path: ExprPath, expr: UserExpression): InsertAsArgResult => (new InsertAsArgResultImpl({
    type: 'insertAsArgResult',
    path,
    expr,
}));

class RemoveResultImpl extends Immutable.Record({
        type: undefined, }) {
}

export type RemoveResult = {
    type: 'removeResult',
    toJS: () => any,
};

export const newRemoveResult = (): RemoveResult => (new RemoveResultImpl({
    type: 'removeResult',
}));

export type DropResult = AddToTopLevelResult | InsertAsBodyResult | InsertAsArgResult | RemoveResult;

export type DropResultVisitor<T> = {
    addToTopLevelResult: (addToTopLevelResult: AddToTopLevelResult) => T,
    insertAsBodyResult: (insertAsBodyResult: InsertAsBodyResult) => T,
    insertAsArgResult: (insertAsArgResult: InsertAsArgResult) => T,
    removeResult: (removeResult: RemoveResult) => T,
}

export const matchDropResult = function<T>(dropResult: DropResult, visitor: DropResultVisitor<T>): T {
    switch (dropResult.type) {
        case 'addToTopLevelResult':
            return visitor.addToTopLevelResult(dropResult);
        case 'insertAsBodyResult':
            return visitor.insertAsBodyResult(dropResult);
        case 'insertAsArgResult':
            return visitor.insertAsArgResult(dropResult);
        case 'removeResult':
            return visitor.removeResult(dropResult);
        default:
            throw new Error('Unexpected type: ' + dropResult.type);
    }
};

class ExpressionKeyImpl extends Immutable.Record({
        type: undefined, exprPath: undefined}) {
    withExprPath(exprPath) {
        return this.set('exprPath', exprPath)
    }
    updateExprPath(updater) {
        return this.set('exprPath', updater(this.exprPath))
    }
}

export type ExpressionKey = {
    type: 'expressionKey',
    exprPath: ExprPath,
    withExprPath: (exprPath: ExprPath) => ExpressionKey,
    updateExprPath: (updater: (exprPath: ExprPath) => ExprPath) => ExpressionKey,
    toJS: () => any,
};

export const newExpressionKey = (exprPath: ExprPath): ExpressionKey => (new ExpressionKeyImpl({
    type: 'expressionKey',
    exprPath,
}));

class EmptyBodyKeyImpl extends Immutable.Record({
        type: undefined, lambdaPath: undefined}) {
    withLambdaPath(lambdaPath) {
        return this.set('lambdaPath', lambdaPath)
    }
    updateLambdaPath(updater) {
        return this.set('lambdaPath', updater(this.lambdaPath))
    }
}

export type EmptyBodyKey = {
    type: 'emptyBodyKey',
    lambdaPath: ExprPath,
    withLambdaPath: (lambdaPath: ExprPath) => EmptyBodyKey,
    updateLambdaPath: (updater: (lambdaPath: ExprPath) => ExprPath) => EmptyBodyKey,
    toJS: () => any,
};

export const newEmptyBodyKey = (lambdaPath: ExprPath): EmptyBodyKey => (new EmptyBodyKeyImpl({
    type: 'emptyBodyKey',
    lambdaPath,
}));

class LambdaVarKeyImpl extends Immutable.Record({
        type: undefined, lambdaPath: undefined}) {
    withLambdaPath(lambdaPath) {
        return this.set('lambdaPath', lambdaPath)
    }
    updateLambdaPath(updater) {
        return this.set('lambdaPath', updater(this.lambdaPath))
    }
}

export type LambdaVarKey = {
    type: 'lambdaVarKey',
    lambdaPath: ExprPath,
    withLambdaPath: (lambdaPath: ExprPath) => LambdaVarKey,
    updateLambdaPath: (updater: (lambdaPath: ExprPath) => ExprPath) => LambdaVarKey,
    toJS: () => any,
};

export const newLambdaVarKey = (lambdaPath: ExprPath): LambdaVarKey => (new LambdaVarKeyImpl({
    type: 'lambdaVarKey',
    lambdaPath,
}));

export type ViewKey = ExpressionKey | EmptyBodyKey | LambdaVarKey;

export type ViewKeyVisitor<T> = {
    expressionKey: (expressionKey: ExpressionKey) => T,
    emptyBodyKey: (emptyBodyKey: EmptyBodyKey) => T,
    lambdaVarKey: (lambdaVarKey: LambdaVarKey) => T,
}

export const matchViewKey = function<T>(viewKey: ViewKey, visitor: ViewKeyVisitor<T>): T {
    switch (viewKey.type) {
        case 'expressionKey':
            return visitor.expressionKey(viewKey);
        case 'emptyBodyKey':
            return visitor.emptyBodyKey(viewKey);
        case 'lambdaVarKey':
            return visitor.lambdaVarKey(viewKey);
        default:
            throw new Error('Unexpected type: ' + viewKey.type);
    }
};

