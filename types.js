/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 */
import {buildUnionCaseClass, buildValueClass} from './types-lib'
import {IList, IMap, ISet} from './types-collections'

 
const StateImpl = buildValueClass('State', ['canvasExpressions', 'nextExprId', 'canvasDefinitions', 'definitions', 'pendingResults', 'activeDrags', 'highlightedExprs', 'highlightedEmptyBodies']);

export const newState = (canvasExpressions: IMap<number, CanvasExpression>, nextExprId: number, canvasDefinitions: IMap<string, CanvasPoint>, definitions: IMap<string, ?UserExpression>, pendingResults: IMap<number, PendingResult>, activeDrags: IMap<number, DragData>, highlightedExprs: ISet<ExprPath>, highlightedEmptyBodies: ISet<ExprPath>): State => (new StateImpl({
    canvasExpressions,
    nextExprId,
    canvasDefinitions,
    definitions,
    pendingResults,
    activeDrags,
    highlightedExprs,
    highlightedEmptyBodies,
}));

const ResetImpl = buildUnionCaseClass('reset', []);

export const newReset = (): Reset => (new ResetImpl({
    type: 'reset',
}));

const AddExpressionImpl = buildUnionCaseClass('addExpression', ['canvasExpr']);

export const newAddExpression = (canvasExpr: CanvasExpression): AddExpression => (new AddExpressionImpl({
    type: 'addExpression',
    canvasExpr,
}));

const PlaceDefinitionImpl = buildUnionCaseClass('placeDefinition', ['defName', 'screenPos']);

export const newPlaceDefinition = (defName: string, screenPos: ScreenPoint): PlaceDefinition => (new PlaceDefinitionImpl({
    type: 'placeDefinition',
    defName,
    screenPos,
}));

const MoveExpressionImpl = buildUnionCaseClass('moveExpression', ['exprId', 'pos']);

export const newMoveExpression = (exprId: number, pos: CanvasPoint): MoveExpression => (new MoveExpressionImpl({
    type: 'moveExpression',
    exprId,
    pos,
}));

const DecomposeExpressionActionImpl = buildUnionCaseClass('decomposeExpressionAction', ['path', 'targetPos']);

export const newDecomposeExpressionAction = (path: ExprPath, targetPos: CanvasPoint): DecomposeExpressionAction => (new DecomposeExpressionActionImpl({
    type: 'decomposeExpressionAction',
    path,
    targetPos,
}));

const InsertAsArgImpl = buildUnionCaseClass('insertAsArg', ['argExprId', 'path']);

export const newInsertAsArg = (argExprId: number, path: ExprPath): InsertAsArg => (new InsertAsArgImpl({
    type: 'insertAsArg',
    argExprId,
    path,
}));

const InsertAsBodyImpl = buildUnionCaseClass('insertAsBody', ['bodyExprId', 'path']);

export const newInsertAsBody = (bodyExprId: number, path: ExprPath): InsertAsBody => (new InsertAsBodyImpl({
    type: 'insertAsBody',
    bodyExprId,
    path,
}));

const EvaluateExpressionImpl = buildUnionCaseClass('evaluateExpression', ['exprId']);

export const newEvaluateExpression = (exprId: number): EvaluateExpression => (new EvaluateExpressionImpl({
    type: 'evaluateExpression',
    exprId,
}));

const PlacePendingResultImpl = buildUnionCaseClass('placePendingResult', ['exprId', 'width', 'height']);

export const newPlacePendingResult = (exprId: number, width: number, height: number): PlacePendingResult => (new PlacePendingResultImpl({
    type: 'placePendingResult',
    exprId,
    width,
    height,
}));

const FingerDownImpl = buildUnionCaseClass('fingerDown', ['fingerId', 'screenPos']);

export const newFingerDown = (fingerId: number, screenPos: ScreenPoint): FingerDown => (new FingerDownImpl({
    type: 'fingerDown',
    fingerId,
    screenPos,
}));

const FingerMoveImpl = buildUnionCaseClass('fingerMove', ['fingerId', 'screenPos']);

export const newFingerMove = (fingerId: number, screenPos: ScreenPoint): FingerMove => (new FingerMoveImpl({
    type: 'fingerMove',
    fingerId,
    screenPos,
}));

const FingerUpImpl = buildUnionCaseClass('fingerUp', ['fingerId', 'screenPos']);

export const newFingerUp = (fingerId: number, screenPos: ScreenPoint): FingerUp => (new FingerUpImpl({
    type: 'fingerUp',
    fingerId,
    screenPos,
}));

const LambdaImpl = buildUnionCaseClass('lambda', ['varName', 'body']);

export const newLambda = (varName: string, body: Expression): Lambda => (new LambdaImpl({
    type: 'lambda',
    varName,
    body,
}));

const FuncCallImpl = buildUnionCaseClass('funcCall', ['func', 'arg']);

export const newFuncCall = (func: Expression, arg: Expression): FuncCall => (new FuncCallImpl({
    type: 'funcCall',
    func,
    arg,
}));

const VariableImpl = buildUnionCaseClass('variable', ['varName']);

export const newVariable = (varName: string): Variable => (new VariableImpl({
    type: 'variable',
    varName,
}));



const EvalLambdaImpl = buildUnionCaseClass('evalLambda', ['varMarker', 'originalVarName', 'body']);

export const newEvalLambda = (varMarker: VarMarker, originalVarName: string, body: EvalExpression): EvalLambda => (new EvalLambdaImpl({
    type: 'evalLambda',
    varMarker,
    originalVarName,
    body,
}));

const EvalFuncCallImpl = buildUnionCaseClass('evalFuncCall', ['func', 'arg']);

export const newEvalFuncCall = (func: EvalExpression, arg: EvalExpression): EvalFuncCall => (new EvalFuncCallImpl({
    type: 'evalFuncCall',
    func,
    arg,
}));

const EvalBoundVariableImpl = buildUnionCaseClass('evalBoundVariable', ['slot']);

export const newEvalBoundVariable = (slot: Slot): EvalBoundVariable => (new EvalBoundVariableImpl({
    type: 'evalBoundVariable',
    slot,
}));

const EvalUnboundVariableImpl = buildUnionCaseClass('evalUnboundVariable', ['varMarker', 'originalVarName']);

export const newEvalUnboundVariable = (varMarker: VarMarker, originalVarName: string): EvalUnboundVariable => (new EvalUnboundVariableImpl({
    type: 'evalUnboundVariable',
    varMarker,
    originalVarName,
}));

const EvalFreeVariableImpl = buildUnionCaseClass('evalFreeVariable', ['varName']);

export const newEvalFreeVariable = (varName: string): EvalFreeVariable => (new EvalFreeVariableImpl({
    type: 'evalFreeVariable',
    varName,
}));

const UserLambdaImpl = buildUnionCaseClass('userLambda', ['varName', 'body']);

export const newUserLambda = (varName: string, body: ?UserExpression): UserLambda => (new UserLambdaImpl({
    type: 'userLambda',
    varName,
    body,
}));

const UserFuncCallImpl = buildUnionCaseClass('userFuncCall', ['func', 'arg']);

export const newUserFuncCall = (func: UserExpression, arg: UserExpression): UserFuncCall => (new UserFuncCallImpl({
    type: 'userFuncCall',
    func,
    arg,
}));

const UserVariableImpl = buildUnionCaseClass('userVariable', ['varName']);

export const newUserVariable = (varName: string): UserVariable => (new UserVariableImpl({
    type: 'userVariable',
    varName,
}));

const UserReferenceImpl = buildUnionCaseClass('userReference', ['defName']);

export const newUserReference = (defName: string): UserReference => (new UserReferenceImpl({
    type: 'userReference',
    defName,
}));


const CanvasExpressionImpl = buildValueClass('CanvasExpression', ['expr', 'pos']);

export const newCanvasExpression = (expr: UserExpression, pos: CanvasPoint): CanvasExpression => (new CanvasExpressionImpl({
    expr,
    pos,
}));


const PendingResultImpl = buildValueClass('PendingResult', ['expr', 'sourceExprId']);

export const newPendingResult = (expr: UserExpression, sourceExprId: number): PendingResult => (new PendingResultImpl({
    expr,
    sourceExprId,
}));


const DisplayStateImpl = buildValueClass('DisplayState', ['screenExpressions', 'screenDefinitions', 'measureRequests']);

export const newDisplayState = (screenExpressions: IList<ScreenExpression>, screenDefinitions: IList<ScreenDefinition>, measureRequests: IList<MeasureRequest>): DisplayState => (new DisplayStateImpl({
    screenExpressions,
    screenDefinitions,
    measureRequests,
}));


const MeasureRequestImpl = buildValueClass('MeasureRequest', ['expr', 'resultHandler']);

export const newMeasureRequest = (expr: DisplayExpression, resultHandler: (width: number, height: number) => void): MeasureRequest => (new MeasureRequestImpl({
    expr,
    resultHandler,
}));


const ScreenDefinitionImpl = buildValueClass('ScreenDefinition', ['defName', 'expr', 'pos', 'key', 'isDragging']);

export const newScreenDefinition = (defName: string, expr: ?DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean): ScreenDefinition => (new ScreenDefinitionImpl({
    defName,
    expr,
    pos,
    key,
    isDragging,
}));


const ScreenExpressionImpl = buildValueClass('ScreenExpression', ['expr', 'pos', 'key', 'isDragging', 'executeHandler']);

export const newScreenExpression = (expr: DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean, executeHandler: ?() => void): ScreenExpression => (new ScreenExpressionImpl({
    expr,
    pos,
    key,
    isDragging,
    executeHandler,
}));

const DisplayLambdaImpl = buildUnionCaseClass('displayLambda', ['exprKey', 'shouldHighlight', 'varKey', 'emptyBodyKey', 'shouldHighlightEmptyBody', 'varName', 'body']);

export const newDisplayLambda = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varKey: ?LambdaVarKey, emptyBodyKey: ?EmptyBodyKey, shouldHighlightEmptyBody: boolean, varName: string, body: ?DisplayExpression): DisplayLambda => (new DisplayLambdaImpl({
    type: 'displayLambda',
    exprKey,
    shouldHighlight,
    varKey,
    emptyBodyKey,
    shouldHighlightEmptyBody,
    varName,
    body,
}));

const DisplayFuncCallImpl = buildUnionCaseClass('displayFuncCall', ['exprKey', 'shouldHighlight', 'func', 'arg']);

export const newDisplayFuncCall = (exprKey: ?ExpressionKey, shouldHighlight: boolean, func: DisplayExpression, arg: DisplayExpression): DisplayFuncCall => (new DisplayFuncCallImpl({
    type: 'displayFuncCall',
    exprKey,
    shouldHighlight,
    func,
    arg,
}));

const DisplayVariableImpl = buildUnionCaseClass('displayVariable', ['exprKey', 'shouldHighlight', 'varName']);

export const newDisplayVariable = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varName: string): DisplayVariable => (new DisplayVariableImpl({
    type: 'displayVariable',
    exprKey,
    shouldHighlight,
    varName,
}));

const DisplayReferenceImpl = buildUnionCaseClass('displayReference', ['exprKey', 'shouldHighlight', 'defName']);

export const newDisplayReference = (exprKey: ?ExpressionKey, shouldHighlight: boolean, defName: string): DisplayReference => (new DisplayReferenceImpl({
    type: 'displayReference',
    exprKey,
    shouldHighlight,
    defName,
}));


const CanvasPointImpl = buildValueClass('CanvasPoint', ['canvasX', 'canvasY']);

export const newCanvasPoint = (canvasX: number, canvasY: number): CanvasPoint => (new CanvasPointImpl({
    canvasX,
    canvasY,
}));


const PointDifferenceImpl = buildValueClass('PointDifference', ['dx', 'dy']);

export const newPointDifference = (dx: number, dy: number): PointDifference => (new PointDifferenceImpl({
    dx,
    dy,
}));


const ScreenPointImpl = buildValueClass('ScreenPoint', ['screenX', 'screenY']);

export const newScreenPoint = (screenX: number, screenY: number): ScreenPoint => (new ScreenPointImpl({
    screenX,
    screenY,
}));


const ScreenRectImpl = buildValueClass('ScreenRect', ['topLeft', 'bottomRight']);

export const newScreenRect = (topLeft: ScreenPoint, bottomRight: ScreenPoint): ScreenRect => (new ScreenRectImpl({
    topLeft,
    bottomRight,
}));



const ExprPathImpl = buildValueClass('ExprPath', ['container', 'pathSteps']);

export const newExprPath = (container: ExprContainer, pathSteps: IList<PathComponent>): ExprPath => (new ExprPathImpl({
    container,
    pathSteps,
}));

const ExprIdContainerImpl = buildUnionCaseClass('exprIdContainer', ['exprId']);

export const newExprIdContainer = (exprId: number): ExprIdContainer => (new ExprIdContainerImpl({
    type: 'exprIdContainer',
    exprId,
}));

const DefinitionContainerImpl = buildUnionCaseClass('definitionContainer', ['defName']);

export const newDefinitionContainer = (defName: string): DefinitionContainer => (new DefinitionContainerImpl({
    type: 'definitionContainer',
    defName,
}));

const PickUpExpressionImpl = buildUnionCaseClass('pickUpExpression', ['exprId', 'offset', 'screenRect']);

export const newPickUpExpression = (exprId: number, offset: PointDifference, screenRect: ScreenRect): PickUpExpression => (new PickUpExpressionImpl({
    type: 'pickUpExpression',
    exprId,
    offset,
    screenRect,
}));

const DecomposeExpressionImpl = buildUnionCaseClass('decomposeExpression', ['exprPath', 'offset', 'screenRect']);

export const newDecomposeExpression = (exprPath: ExprPath, offset: PointDifference, screenRect: ScreenRect): DecomposeExpression => (new DecomposeExpressionImpl({
    type: 'decomposeExpression',
    exprPath,
    offset,
    screenRect,
}));

const CreateExpressionImpl = buildUnionCaseClass('createExpression', ['expr', 'offset', 'screenRect']);

export const newCreateExpression = (expr: UserExpression, offset: PointDifference, screenRect: ScreenRect): CreateExpression => (new CreateExpressionImpl({
    type: 'createExpression',
    expr,
    offset,
    screenRect,
}));

const StartPanImpl = buildUnionCaseClass('startPan', ['startPos']);

export const newStartPan = (startPos: ScreenPoint): StartPan => (new StartPanImpl({
    type: 'startPan',
    startPos,
}));


const DragDataImpl = buildValueClass('DragData', ['userExpr', 'grabOffset', 'screenRect']);

export const newDragData = (userExpr: UserExpression, grabOffset: PointDifference, screenRect: ScreenRect): DragData => (new DragDataImpl({
    userExpr,
    grabOffset,
    screenRect,
}));

const AddToTopLevelResultImpl = buildUnionCaseClass('addToTopLevelResult', ['expr', 'screenPos']);

export const newAddToTopLevelResult = (expr: UserExpression, screenPos: ScreenPoint): AddToTopLevelResult => (new AddToTopLevelResultImpl({
    type: 'addToTopLevelResult',
    expr,
    screenPos,
}));

const InsertAsBodyResultImpl = buildUnionCaseClass('insertAsBodyResult', ['lambdaPath', 'expr']);

export const newInsertAsBodyResult = (lambdaPath: ExprPath, expr: UserExpression): InsertAsBodyResult => (new InsertAsBodyResultImpl({
    type: 'insertAsBodyResult',
    lambdaPath,
    expr,
}));

const InsertAsArgResultImpl = buildUnionCaseClass('insertAsArgResult', ['path', 'expr']);

export const newInsertAsArgResult = (path: ExprPath, expr: UserExpression): InsertAsArgResult => (new InsertAsArgResultImpl({
    type: 'insertAsArgResult',
    path,
    expr,
}));

const RemoveResultImpl = buildUnionCaseClass('removeResult', []);

export const newRemoveResult = (): RemoveResult => (new RemoveResultImpl({
    type: 'removeResult',
}));

const ExpressionKeyImpl = buildUnionCaseClass('expressionKey', ['exprPath']);

export const newExpressionKey = (exprPath: ExprPath): ExpressionKey => (new ExpressionKeyImpl({
    type: 'expressionKey',
    exprPath,
}));

const EmptyBodyKeyImpl = buildUnionCaseClass('emptyBodyKey', ['lambdaPath']);

export const newEmptyBodyKey = (lambdaPath: ExprPath): EmptyBodyKey => (new EmptyBodyKeyImpl({
    type: 'emptyBodyKey',
    lambdaPath,
}));

const LambdaVarKeyImpl = buildUnionCaseClass('lambdaVarKey', ['lambdaPath']);

export const newLambdaVarKey = (lambdaPath: ExprPath): LambdaVarKey => (new LambdaVarKeyImpl({
    type: 'lambdaVarKey',
    lambdaPath,
}));

const DefinitionKeyImpl = buildUnionCaseClass('definitionKey', ['defName']);

export const newDefinitionKey = (defName: string): DefinitionKey => (new DefinitionKeyImpl({
    type: 'definitionKey',
    defName,
}));

