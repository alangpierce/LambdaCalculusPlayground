/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 *
 * @flow
 */
 
import * as Immutable from 'immutable'

import {buildUnionCaseClass, buildValueClass} from './types-lib'
import type {Updater} from './types-lib'

const StateImpl = buildValueClass('State', ['canvasExpressions', 'nextExprId', 'canvasDefinitions', 'definitions', 'pendingResults', 'activeDrags', 'highlightedExprs', 'highlightedEmptyBodies']);

export type State = {
    canvasExpressions: Immutable.Map<number, CanvasExpression>,
    nextExprId: number,
    canvasDefinitions: Immutable.Map<string, CanvasPoint>,
    definitions: Immutable.Map<string, ?UserExpression>,
    pendingResults: Immutable.Map<number, PendingResult>,
    activeDrags: Immutable.Map<number, DragData>,
    highlightedExprs: Immutable.Set<ExprPath>,
    highlightedEmptyBodies: Immutable.Set<ExprPath>,
    withCanvasExpressions(canvasExpressions: Immutable.Map<number, CanvasExpression>): State,
    withNextExprId(nextExprId: number): State,
    withCanvasDefinitions(canvasDefinitions: Immutable.Map<string, CanvasPoint>): State,
    withDefinitions(definitions: Immutable.Map<string, ?UserExpression>): State,
    withPendingResults(pendingResults: Immutable.Map<number, PendingResult>): State,
    withActiveDrags(activeDrags: Immutable.Map<number, DragData>): State,
    withHighlightedExprs(highlightedExprs: Immutable.Set<ExprPath>): State,
    withHighlightedEmptyBodies(highlightedEmptyBodies: Immutable.Set<ExprPath>): State,
    updateCanvasExpressions(updater: Updater<Immutable.Map<number, CanvasExpression>>): State,
    updateNextExprId(updater: Updater<number>): State,
    updateCanvasDefinitions(updater: Updater<Immutable.Map<string, CanvasPoint>>): State,
    updateDefinitions(updater: Updater<Immutable.Map<string, ?UserExpression>>): State,
    updatePendingResults(updater: Updater<Immutable.Map<number, PendingResult>>): State,
    updateActiveDrags(updater: Updater<Immutable.Map<number, DragData>>): State,
    updateHighlightedExprs(updater: Updater<Immutable.Set<ExprPath>>): State,
    updateHighlightedEmptyBodies(updater: Updater<Immutable.Set<ExprPath>>): State,
    toJS(): any,
    serialize(): any,
};

export const newState = (canvasExpressions: Immutable.Map<number, CanvasExpression>, nextExprId: number, canvasDefinitions: Immutable.Map<string, CanvasPoint>, definitions: Immutable.Map<string, ?UserExpression>, pendingResults: Immutable.Map<number, PendingResult>, activeDrags: Immutable.Map<number, DragData>, highlightedExprs: Immutable.Set<ExprPath>, highlightedEmptyBodies: Immutable.Set<ExprPath>): State => (new StateImpl({
    canvasExpressions,
    nextExprId,
    canvasDefinitions,
    definitions,
    pendingResults,
    activeDrags,
    highlightedExprs,
    highlightedEmptyBodies,
}));

const ResetImpl = buildUnionCaseClass('reset', []);
export type Reset = {
    type: 'reset',
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newReset = (): Reset => (new ResetImpl({
    type: 'reset',
}));

const AddExpressionImpl = buildUnionCaseClass('addExpression', ['canvasExpr']);
export type AddExpression = {
    type: 'addExpression',
    canvasExpr: CanvasExpression,
    withCanvasExpr(canvasExpr: CanvasExpression): AddExpression,
    updateCanvasExpr(updater: Updater<CanvasExpression>): AddExpression,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newAddExpression = (canvasExpr: CanvasExpression): AddExpression => (new AddExpressionImpl({
    type: 'addExpression',
    canvasExpr,
}));

const PlaceDefinitionImpl = buildUnionCaseClass('placeDefinition', ['defName', 'screenPos']);
export type PlaceDefinition = {
    type: 'placeDefinition',
    defName: string,
    screenPos: ScreenPoint,
    withDefName(defName: string): PlaceDefinition,
    withScreenPos(screenPos: ScreenPoint): PlaceDefinition,
    updateDefName(updater: Updater<string>): PlaceDefinition,
    updateScreenPos(updater: Updater<ScreenPoint>): PlaceDefinition,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newPlaceDefinition = (defName: string, screenPos: ScreenPoint): PlaceDefinition => (new PlaceDefinitionImpl({
    type: 'placeDefinition',
    defName,
    screenPos,
}));

const MoveExpressionImpl = buildUnionCaseClass('moveExpression', ['exprId', 'pos']);
export type MoveExpression = {
    type: 'moveExpression',
    exprId: number,
    pos: CanvasPoint,
    withExprId(exprId: number): MoveExpression,
    withPos(pos: CanvasPoint): MoveExpression,
    updateExprId(updater: Updater<number>): MoveExpression,
    updatePos(updater: Updater<CanvasPoint>): MoveExpression,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newMoveExpression = (exprId: number, pos: CanvasPoint): MoveExpression => (new MoveExpressionImpl({
    type: 'moveExpression',
    exprId,
    pos,
}));

const DecomposeExpressionActionImpl = buildUnionCaseClass('decomposeExpressionAction', ['path', 'targetPos']);
export type DecomposeExpressionAction = {
    type: 'decomposeExpressionAction',
    path: ExprPath,
    targetPos: CanvasPoint,
    withPath(path: ExprPath): DecomposeExpressionAction,
    withTargetPos(targetPos: CanvasPoint): DecomposeExpressionAction,
    updatePath(updater: Updater<ExprPath>): DecomposeExpressionAction,
    updateTargetPos(updater: Updater<CanvasPoint>): DecomposeExpressionAction,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDecomposeExpressionAction = (path: ExprPath, targetPos: CanvasPoint): DecomposeExpressionAction => (new DecomposeExpressionActionImpl({
    type: 'decomposeExpressionAction',
    path,
    targetPos,
}));

const InsertAsArgImpl = buildUnionCaseClass('insertAsArg', ['argExprId', 'path']);
export type InsertAsArg = {
    type: 'insertAsArg',
    argExprId: number,
    path: ExprPath,
    withArgExprId(argExprId: number): InsertAsArg,
    withPath(path: ExprPath): InsertAsArg,
    updateArgExprId(updater: Updater<number>): InsertAsArg,
    updatePath(updater: Updater<ExprPath>): InsertAsArg,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newInsertAsArg = (argExprId: number, path: ExprPath): InsertAsArg => (new InsertAsArgImpl({
    type: 'insertAsArg',
    argExprId,
    path,
}));

const InsertAsBodyImpl = buildUnionCaseClass('insertAsBody', ['bodyExprId', 'path']);
export type InsertAsBody = {
    type: 'insertAsBody',
    bodyExprId: number,
    path: ExprPath,
    withBodyExprId(bodyExprId: number): InsertAsBody,
    withPath(path: ExprPath): InsertAsBody,
    updateBodyExprId(updater: Updater<number>): InsertAsBody,
    updatePath(updater: Updater<ExprPath>): InsertAsBody,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newInsertAsBody = (bodyExprId: number, path: ExprPath): InsertAsBody => (new InsertAsBodyImpl({
    type: 'insertAsBody',
    bodyExprId,
    path,
}));

const EvaluateExpressionImpl = buildUnionCaseClass('evaluateExpression', ['exprId']);
export type EvaluateExpression = {
    type: 'evaluateExpression',
    exprId: number,
    withExprId(exprId: number): EvaluateExpression,
    updateExprId(updater: Updater<number>): EvaluateExpression,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newEvaluateExpression = (exprId: number): EvaluateExpression => (new EvaluateExpressionImpl({
    type: 'evaluateExpression',
    exprId,
}));

const PlacePendingResultImpl = buildUnionCaseClass('placePendingResult', ['exprId', 'width', 'height']);
export type PlacePendingResult = {
    type: 'placePendingResult',
    exprId: number,
    width: number,
    height: number,
    withExprId(exprId: number): PlacePendingResult,
    withWidth(width: number): PlacePendingResult,
    withHeight(height: number): PlacePendingResult,
    updateExprId(updater: Updater<number>): PlacePendingResult,
    updateWidth(updater: Updater<number>): PlacePendingResult,
    updateHeight(updater: Updater<number>): PlacePendingResult,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newPlacePendingResult = (exprId: number, width: number, height: number): PlacePendingResult => (new PlacePendingResultImpl({
    type: 'placePendingResult',
    exprId,
    width,
    height,
}));

const FingerDownImpl = buildUnionCaseClass('fingerDown', ['fingerId', 'screenPos']);
export type FingerDown = {
    type: 'fingerDown',
    fingerId: number,
    screenPos: ScreenPoint,
    withFingerId(fingerId: number): FingerDown,
    withScreenPos(screenPos: ScreenPoint): FingerDown,
    updateFingerId(updater: Updater<number>): FingerDown,
    updateScreenPos(updater: Updater<ScreenPoint>): FingerDown,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newFingerDown = (fingerId: number, screenPos: ScreenPoint): FingerDown => (new FingerDownImpl({
    type: 'fingerDown',
    fingerId,
    screenPos,
}));

const FingerMoveImpl = buildUnionCaseClass('fingerMove', ['fingerId', 'screenPos']);
export type FingerMove = {
    type: 'fingerMove',
    fingerId: number,
    screenPos: ScreenPoint,
    withFingerId(fingerId: number): FingerMove,
    withScreenPos(screenPos: ScreenPoint): FingerMove,
    updateFingerId(updater: Updater<number>): FingerMove,
    updateScreenPos(updater: Updater<ScreenPoint>): FingerMove,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newFingerMove = (fingerId: number, screenPos: ScreenPoint): FingerMove => (new FingerMoveImpl({
    type: 'fingerMove',
    fingerId,
    screenPos,
}));

const FingerUpImpl = buildUnionCaseClass('fingerUp', ['fingerId', 'screenPos']);
export type FingerUp = {
    type: 'fingerUp',
    fingerId: number,
    screenPos: ScreenPoint,
    withFingerId(fingerId: number): FingerUp,
    withScreenPos(screenPos: ScreenPoint): FingerUp,
    updateFingerId(updater: Updater<number>): FingerUp,
    updateScreenPos(updater: Updater<ScreenPoint>): FingerUp,
    match<T>(visitor: ActionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newFingerUp = (fingerId: number, screenPos: ScreenPoint): FingerUp => (new FingerUpImpl({
    type: 'fingerUp',
    fingerId,
    screenPos,
}));

export type Action = Reset | AddExpression | PlaceDefinition | MoveExpression | DecomposeExpressionAction | InsertAsArg | InsertAsBody | EvaluateExpression | PlacePendingResult | FingerDown | FingerMove | FingerUp;

export type ActionVisitor<T> = {
    reset(reset: Reset): T,
    addExpression(addExpression: AddExpression): T,
    placeDefinition(placeDefinition: PlaceDefinition): T,
    moveExpression(moveExpression: MoveExpression): T,
    decomposeExpressionAction(decomposeExpressionAction: DecomposeExpressionAction): T,
    insertAsArg(insertAsArg: InsertAsArg): T,
    insertAsBody(insertAsBody: InsertAsBody): T,
    evaluateExpression(evaluateExpression: EvaluateExpression): T,
    placePendingResult(placePendingResult: PlacePendingResult): T,
    fingerDown(fingerDown: FingerDown): T,
    fingerMove(fingerMove: FingerMove): T,
    fingerUp(fingerUp: FingerUp): T,
}

const LambdaImpl = buildUnionCaseClass('lambda', ['varName', 'body']);
export type Lambda = {
    type: 'lambda',
    varName: string,
    body: Expression,
    withVarName(varName: string): Lambda,
    withBody(body: Expression): Lambda,
    updateVarName(updater: Updater<string>): Lambda,
    updateBody(updater: Updater<Expression>): Lambda,
    match<T>(visitor: ExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newLambda = (varName: string, body: Expression): Lambda => (new LambdaImpl({
    type: 'lambda',
    varName,
    body,
}));

const FuncCallImpl = buildUnionCaseClass('funcCall', ['func', 'arg']);
export type FuncCall = {
    type: 'funcCall',
    func: Expression,
    arg: Expression,
    withFunc(func: Expression): FuncCall,
    withArg(arg: Expression): FuncCall,
    updateFunc(updater: Updater<Expression>): FuncCall,
    updateArg(updater: Updater<Expression>): FuncCall,
    match<T>(visitor: ExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newFuncCall = (func: Expression, arg: Expression): FuncCall => (new FuncCallImpl({
    type: 'funcCall',
    func,
    arg,
}));

const VariableImpl = buildUnionCaseClass('variable', ['varName']);
export type Variable = {
    type: 'variable',
    varName: string,
    withVarName(varName: string): Variable,
    updateVarName(updater: Updater<string>): Variable,
    match<T>(visitor: ExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newVariable = (varName: string): Variable => (new VariableImpl({
    type: 'variable',
    varName,
}));

export type Expression = Lambda | FuncCall | Variable;

export type ExpressionVisitor<T> = {
    lambda(lambda: Lambda): T,
    funcCall(funcCall: FuncCall): T,
    variable(variable: Variable): T,
}

export type Slot = {
    isValue: boolean,
    expr: EvalExpression,
    originalVarName: string
};

export type VarMarker = number;

const EvalLambdaImpl = buildUnionCaseClass('evalLambda', ['varMarker', 'originalVarName', 'body']);
export type EvalLambda = {
    type: 'evalLambda',
    varMarker: VarMarker,
    originalVarName: string,
    body: EvalExpression,
    withVarMarker(varMarker: VarMarker): EvalLambda,
    withOriginalVarName(originalVarName: string): EvalLambda,
    withBody(body: EvalExpression): EvalLambda,
    updateVarMarker(updater: Updater<VarMarker>): EvalLambda,
    updateOriginalVarName(updater: Updater<string>): EvalLambda,
    updateBody(updater: Updater<EvalExpression>): EvalLambda,
    match<T>(visitor: EvalExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newEvalLambda = (varMarker: VarMarker, originalVarName: string, body: EvalExpression): EvalLambda => (new EvalLambdaImpl({
    type: 'evalLambda',
    varMarker,
    originalVarName,
    body,
}));

const EvalFuncCallImpl = buildUnionCaseClass('evalFuncCall', ['func', 'arg']);
export type EvalFuncCall = {
    type: 'evalFuncCall',
    func: EvalExpression,
    arg: EvalExpression,
    withFunc(func: EvalExpression): EvalFuncCall,
    withArg(arg: EvalExpression): EvalFuncCall,
    updateFunc(updater: Updater<EvalExpression>): EvalFuncCall,
    updateArg(updater: Updater<EvalExpression>): EvalFuncCall,
    match<T>(visitor: EvalExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newEvalFuncCall = (func: EvalExpression, arg: EvalExpression): EvalFuncCall => (new EvalFuncCallImpl({
    type: 'evalFuncCall',
    func,
    arg,
}));

const EvalBoundVariableImpl = buildUnionCaseClass('evalBoundVariable', ['slot']);
export type EvalBoundVariable = {
    type: 'evalBoundVariable',
    slot: Slot,
    withSlot(slot: Slot): EvalBoundVariable,
    updateSlot(updater: Updater<Slot>): EvalBoundVariable,
    match<T>(visitor: EvalExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newEvalBoundVariable = (slot: Slot): EvalBoundVariable => (new EvalBoundVariableImpl({
    type: 'evalBoundVariable',
    slot,
}));

const EvalUnboundVariableImpl = buildUnionCaseClass('evalUnboundVariable', ['varMarker', 'originalVarName']);
export type EvalUnboundVariable = {
    type: 'evalUnboundVariable',
    varMarker: VarMarker,
    originalVarName: string,
    withVarMarker(varMarker: VarMarker): EvalUnboundVariable,
    withOriginalVarName(originalVarName: string): EvalUnboundVariable,
    updateVarMarker(updater: Updater<VarMarker>): EvalUnboundVariable,
    updateOriginalVarName(updater: Updater<string>): EvalUnboundVariable,
    match<T>(visitor: EvalExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newEvalUnboundVariable = (varMarker: VarMarker, originalVarName: string): EvalUnboundVariable => (new EvalUnboundVariableImpl({
    type: 'evalUnboundVariable',
    varMarker,
    originalVarName,
}));

const EvalFreeVariableImpl = buildUnionCaseClass('evalFreeVariable', ['varName']);
export type EvalFreeVariable = {
    type: 'evalFreeVariable',
    varName: string,
    withVarName(varName: string): EvalFreeVariable,
    updateVarName(updater: Updater<string>): EvalFreeVariable,
    match<T>(visitor: EvalExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newEvalFreeVariable = (varName: string): EvalFreeVariable => (new EvalFreeVariableImpl({
    type: 'evalFreeVariable',
    varName,
}));

export type EvalExpression = EvalLambda | EvalFuncCall | EvalBoundVariable | EvalUnboundVariable | EvalFreeVariable;

export type EvalExpressionVisitor<T> = {
    evalLambda(evalLambda: EvalLambda): T,
    evalFuncCall(evalFuncCall: EvalFuncCall): T,
    evalBoundVariable(evalBoundVariable: EvalBoundVariable): T,
    evalUnboundVariable(evalUnboundVariable: EvalUnboundVariable): T,
    evalFreeVariable(evalFreeVariable: EvalFreeVariable): T,
}

const UserLambdaImpl = buildUnionCaseClass('userLambda', ['varName', 'body']);
export type UserLambda = {
    type: 'userLambda',
    varName: string,
    body: ?UserExpression,
    withVarName(varName: string): UserLambda,
    withBody(body: ?UserExpression): UserLambda,
    updateVarName(updater: Updater<string>): UserLambda,
    updateBody(updater: Updater<?UserExpression>): UserLambda,
    match<T>(visitor: UserExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newUserLambda = (varName: string, body: ?UserExpression): UserLambda => (new UserLambdaImpl({
    type: 'userLambda',
    varName,
    body,
}));

const UserFuncCallImpl = buildUnionCaseClass('userFuncCall', ['func', 'arg']);
export type UserFuncCall = {
    type: 'userFuncCall',
    func: UserExpression,
    arg: UserExpression,
    withFunc(func: UserExpression): UserFuncCall,
    withArg(arg: UserExpression): UserFuncCall,
    updateFunc(updater: Updater<UserExpression>): UserFuncCall,
    updateArg(updater: Updater<UserExpression>): UserFuncCall,
    match<T>(visitor: UserExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newUserFuncCall = (func: UserExpression, arg: UserExpression): UserFuncCall => (new UserFuncCallImpl({
    type: 'userFuncCall',
    func,
    arg,
}));

const UserVariableImpl = buildUnionCaseClass('userVariable', ['varName']);
export type UserVariable = {
    type: 'userVariable',
    varName: string,
    withVarName(varName: string): UserVariable,
    updateVarName(updater: Updater<string>): UserVariable,
    match<T>(visitor: UserExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newUserVariable = (varName: string): UserVariable => (new UserVariableImpl({
    type: 'userVariable',
    varName,
}));

const UserReferenceImpl = buildUnionCaseClass('userReference', ['defName']);
export type UserReference = {
    type: 'userReference',
    defName: string,
    withDefName(defName: string): UserReference,
    updateDefName(updater: Updater<string>): UserReference,
    match<T>(visitor: UserExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newUserReference = (defName: string): UserReference => (new UserReferenceImpl({
    type: 'userReference',
    defName,
}));

export type UserExpression = UserLambda | UserFuncCall | UserVariable | UserReference;

export type UserExpressionVisitor<T> = {
    userLambda(userLambda: UserLambda): T,
    userFuncCall(userFuncCall: UserFuncCall): T,
    userVariable(userVariable: UserVariable): T,
    userReference(userReference: UserReference): T,
}

const CanvasExpressionImpl = buildValueClass('CanvasExpression', ['expr', 'pos']);

export type CanvasExpression = {
    expr: UserExpression,
    pos: CanvasPoint,
    withExpr(expr: UserExpression): CanvasExpression,
    withPos(pos: CanvasPoint): CanvasExpression,
    updateExpr(updater: Updater<UserExpression>): CanvasExpression,
    updatePos(updater: Updater<CanvasPoint>): CanvasExpression,
    toJS(): any,
    serialize(): any,
};

export const newCanvasExpression = (expr: UserExpression, pos: CanvasPoint): CanvasExpression => (new CanvasExpressionImpl({
    expr,
    pos,
}));

const PendingResultImpl = buildValueClass('PendingResult', ['expr', 'sourceExprId']);

export type PendingResult = {
    expr: UserExpression,
    sourceExprId: number,
    withExpr(expr: UserExpression): PendingResult,
    withSourceExprId(sourceExprId: number): PendingResult,
    updateExpr(updater: Updater<UserExpression>): PendingResult,
    updateSourceExprId(updater: Updater<number>): PendingResult,
    toJS(): any,
    serialize(): any,
};

export const newPendingResult = (expr: UserExpression, sourceExprId: number): PendingResult => (new PendingResultImpl({
    expr,
    sourceExprId,
}));

const DisplayStateImpl = buildValueClass('DisplayState', ['screenExpressions', 'screenDefinitions', 'measureRequests']);

export type DisplayState = {
    screenExpressions: Immutable.List<ScreenExpression>,
    screenDefinitions: Immutable.List<ScreenDefinition>,
    measureRequests: Immutable.List<MeasureRequest>,
    withScreenExpressions(screenExpressions: Immutable.List<ScreenExpression>): DisplayState,
    withScreenDefinitions(screenDefinitions: Immutable.List<ScreenDefinition>): DisplayState,
    withMeasureRequests(measureRequests: Immutable.List<MeasureRequest>): DisplayState,
    updateScreenExpressions(updater: Updater<Immutable.List<ScreenExpression>>): DisplayState,
    updateScreenDefinitions(updater: Updater<Immutable.List<ScreenDefinition>>): DisplayState,
    updateMeasureRequests(updater: Updater<Immutable.List<MeasureRequest>>): DisplayState,
    toJS(): any,
    serialize(): any,
};

export const newDisplayState = (screenExpressions: Immutable.List<ScreenExpression>, screenDefinitions: Immutable.List<ScreenDefinition>, measureRequests: Immutable.List<MeasureRequest>): DisplayState => (new DisplayStateImpl({
    screenExpressions,
    screenDefinitions,
    measureRequests,
}));

const MeasureRequestImpl = buildValueClass('MeasureRequest', ['expr', 'resultHandler']);

export type MeasureRequest = {
    expr: DisplayExpression,
    resultHandler: (width: number, height: number) => void,
    withExpr(expr: DisplayExpression): MeasureRequest,
    withResultHandler(resultHandler: (width: number, height: number) => void): MeasureRequest,
    updateExpr(updater: Updater<DisplayExpression>): MeasureRequest,
    updateResultHandler(updater: Updater<(width: number, height: number) => void>): MeasureRequest,
    toJS(): any,
    serialize(): any,
};

export const newMeasureRequest = (expr: DisplayExpression, resultHandler: (width: number, height: number) => void): MeasureRequest => (new MeasureRequestImpl({
    expr,
    resultHandler,
}));

const ScreenDefinitionImpl = buildValueClass('ScreenDefinition', ['defName', 'expr', 'pos', 'key', 'isDragging']);

export type ScreenDefinition = {
    defName: string,
    expr: ?DisplayExpression,
    pos: ScreenPoint,
    key: string,
    isDragging: boolean,
    withDefName(defName: string): ScreenDefinition,
    withExpr(expr: ?DisplayExpression): ScreenDefinition,
    withPos(pos: ScreenPoint): ScreenDefinition,
    withKey(key: string): ScreenDefinition,
    withIsDragging(isDragging: boolean): ScreenDefinition,
    updateDefName(updater: Updater<string>): ScreenDefinition,
    updateExpr(updater: Updater<?DisplayExpression>): ScreenDefinition,
    updatePos(updater: Updater<ScreenPoint>): ScreenDefinition,
    updateKey(updater: Updater<string>): ScreenDefinition,
    updateIsDragging(updater: Updater<boolean>): ScreenDefinition,
    toJS(): any,
    serialize(): any,
};

export const newScreenDefinition = (defName: string, expr: ?DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean): ScreenDefinition => (new ScreenDefinitionImpl({
    defName,
    expr,
    pos,
    key,
    isDragging,
}));

const ScreenExpressionImpl = buildValueClass('ScreenExpression', ['expr', 'pos', 'key', 'isDragging', 'executeHandler']);

export type ScreenExpression = {
    expr: DisplayExpression,
    pos: ScreenPoint,
    key: string,
    isDragging: boolean,
    executeHandler: ?() => void,
    withExpr(expr: DisplayExpression): ScreenExpression,
    withPos(pos: ScreenPoint): ScreenExpression,
    withKey(key: string): ScreenExpression,
    withIsDragging(isDragging: boolean): ScreenExpression,
    withExecuteHandler(executeHandler: ?() => void): ScreenExpression,
    updateExpr(updater: Updater<DisplayExpression>): ScreenExpression,
    updatePos(updater: Updater<ScreenPoint>): ScreenExpression,
    updateKey(updater: Updater<string>): ScreenExpression,
    updateIsDragging(updater: Updater<boolean>): ScreenExpression,
    updateExecuteHandler(updater: Updater<?() => void>): ScreenExpression,
    toJS(): any,
    serialize(): any,
};

export const newScreenExpression = (expr: DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean, executeHandler: ?() => void): ScreenExpression => (new ScreenExpressionImpl({
    expr,
    pos,
    key,
    isDragging,
    executeHandler,
}));

const DisplayLambdaImpl = buildUnionCaseClass('displayLambda', ['exprKey', 'shouldHighlight', 'varKey', 'emptyBodyKey', 'shouldHighlightEmptyBody', 'varName', 'body']);
export type DisplayLambda = {
    type: 'displayLambda',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    varKey: ?LambdaVarKey,
    emptyBodyKey: ?EmptyBodyKey,
    shouldHighlightEmptyBody: boolean,
    varName: string,
    body: ?DisplayExpression,
    withExprKey(exprKey: ?ExpressionKey): DisplayLambda,
    withShouldHighlight(shouldHighlight: boolean): DisplayLambda,
    withVarKey(varKey: ?LambdaVarKey): DisplayLambda,
    withEmptyBodyKey(emptyBodyKey: ?EmptyBodyKey): DisplayLambda,
    withShouldHighlightEmptyBody(shouldHighlightEmptyBody: boolean): DisplayLambda,
    withVarName(varName: string): DisplayLambda,
    withBody(body: ?DisplayExpression): DisplayLambda,
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayLambda,
    updateShouldHighlight(updater: Updater<boolean>): DisplayLambda,
    updateVarKey(updater: Updater<?LambdaVarKey>): DisplayLambda,
    updateEmptyBodyKey(updater: Updater<?EmptyBodyKey>): DisplayLambda,
    updateShouldHighlightEmptyBody(updater: Updater<boolean>): DisplayLambda,
    updateVarName(updater: Updater<string>): DisplayLambda,
    updateBody(updater: Updater<?DisplayExpression>): DisplayLambda,
    match<T>(visitor: DisplayExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDisplayLambda = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varKey: ?LambdaVarKey, emptyBodyKey: ?EmptyBodyKey, shouldHighlightEmptyBody: boolean, varName: string, body: ?DisplayExpression): DisplayLambda => (new DisplayLambdaImpl({
    type: 'displayLambda',
    exprKey,
    shouldHighlight,
    varKey,
    emptyBodyKey,
    shouldHighlightEmptyBody,
    varName,
    body,
}));

const DisplayFuncCallImpl = buildUnionCaseClass('displayFuncCall', ['exprKey', 'shouldHighlight', 'func', 'arg']);
export type DisplayFuncCall = {
    type: 'displayFuncCall',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    func: DisplayExpression,
    arg: DisplayExpression,
    withExprKey(exprKey: ?ExpressionKey): DisplayFuncCall,
    withShouldHighlight(shouldHighlight: boolean): DisplayFuncCall,
    withFunc(func: DisplayExpression): DisplayFuncCall,
    withArg(arg: DisplayExpression): DisplayFuncCall,
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayFuncCall,
    updateShouldHighlight(updater: Updater<boolean>): DisplayFuncCall,
    updateFunc(updater: Updater<DisplayExpression>): DisplayFuncCall,
    updateArg(updater: Updater<DisplayExpression>): DisplayFuncCall,
    match<T>(visitor: DisplayExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDisplayFuncCall = (exprKey: ?ExpressionKey, shouldHighlight: boolean, func: DisplayExpression, arg: DisplayExpression): DisplayFuncCall => (new DisplayFuncCallImpl({
    type: 'displayFuncCall',
    exprKey,
    shouldHighlight,
    func,
    arg,
}));

const DisplayVariableImpl = buildUnionCaseClass('displayVariable', ['exprKey', 'shouldHighlight', 'varName']);
export type DisplayVariable = {
    type: 'displayVariable',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    varName: string,
    withExprKey(exprKey: ?ExpressionKey): DisplayVariable,
    withShouldHighlight(shouldHighlight: boolean): DisplayVariable,
    withVarName(varName: string): DisplayVariable,
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayVariable,
    updateShouldHighlight(updater: Updater<boolean>): DisplayVariable,
    updateVarName(updater: Updater<string>): DisplayVariable,
    match<T>(visitor: DisplayExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDisplayVariable = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varName: string): DisplayVariable => (new DisplayVariableImpl({
    type: 'displayVariable',
    exprKey,
    shouldHighlight,
    varName,
}));

const DisplayReferenceImpl = buildUnionCaseClass('displayReference', ['exprKey', 'shouldHighlight', 'defName']);
export type DisplayReference = {
    type: 'displayReference',
    exprKey: ?ExpressionKey,
    shouldHighlight: boolean,
    defName: string,
    withExprKey(exprKey: ?ExpressionKey): DisplayReference,
    withShouldHighlight(shouldHighlight: boolean): DisplayReference,
    withDefName(defName: string): DisplayReference,
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayReference,
    updateShouldHighlight(updater: Updater<boolean>): DisplayReference,
    updateDefName(updater: Updater<string>): DisplayReference,
    match<T>(visitor: DisplayExpressionVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDisplayReference = (exprKey: ?ExpressionKey, shouldHighlight: boolean, defName: string): DisplayReference => (new DisplayReferenceImpl({
    type: 'displayReference',
    exprKey,
    shouldHighlight,
    defName,
}));

export type DisplayExpression = DisplayLambda | DisplayFuncCall | DisplayVariable | DisplayReference;

export type DisplayExpressionVisitor<T> = {
    displayLambda(displayLambda: DisplayLambda): T,
    displayFuncCall(displayFuncCall: DisplayFuncCall): T,
    displayVariable(displayVariable: DisplayVariable): T,
    displayReference(displayReference: DisplayReference): T,
}

const CanvasPointImpl = buildValueClass('CanvasPoint', ['canvasX', 'canvasY']);

export type CanvasPoint = {
    canvasX: number,
    canvasY: number,
    withCanvasX(canvasX: number): CanvasPoint,
    withCanvasY(canvasY: number): CanvasPoint,
    updateCanvasX(updater: Updater<number>): CanvasPoint,
    updateCanvasY(updater: Updater<number>): CanvasPoint,
    toJS(): any,
    serialize(): any,
};

export const newCanvasPoint = (canvasX: number, canvasY: number): CanvasPoint => (new CanvasPointImpl({
    canvasX,
    canvasY,
}));

const PointDifferenceImpl = buildValueClass('PointDifference', ['dx', 'dy']);

export type PointDifference = {
    dx: number,
    dy: number,
    withDx(dx: number): PointDifference,
    withDy(dy: number): PointDifference,
    updateDx(updater: Updater<number>): PointDifference,
    updateDy(updater: Updater<number>): PointDifference,
    toJS(): any,
    serialize(): any,
};

export const newPointDifference = (dx: number, dy: number): PointDifference => (new PointDifferenceImpl({
    dx,
    dy,
}));

const ScreenPointImpl = buildValueClass('ScreenPoint', ['screenX', 'screenY']);

export type ScreenPoint = {
    screenX: number,
    screenY: number,
    withScreenX(screenX: number): ScreenPoint,
    withScreenY(screenY: number): ScreenPoint,
    updateScreenX(updater: Updater<number>): ScreenPoint,
    updateScreenY(updater: Updater<number>): ScreenPoint,
    toJS(): any,
    serialize(): any,
};

export const newScreenPoint = (screenX: number, screenY: number): ScreenPoint => (new ScreenPointImpl({
    screenX,
    screenY,
}));

const ScreenRectImpl = buildValueClass('ScreenRect', ['topLeft', 'bottomRight']);

export type ScreenRect = {
    topLeft: ScreenPoint,
    bottomRight: ScreenPoint,
    withTopLeft(topLeft: ScreenPoint): ScreenRect,
    withBottomRight(bottomRight: ScreenPoint): ScreenRect,
    updateTopLeft(updater: Updater<ScreenPoint>): ScreenRect,
    updateBottomRight(updater: Updater<ScreenPoint>): ScreenRect,
    toJS(): any,
    serialize(): any,
};

export const newScreenRect = (topLeft: ScreenPoint, bottomRight: ScreenPoint): ScreenRect => (new ScreenRectImpl({
    topLeft,
    bottomRight,
}));

export type PathComponent = 'func' | 'arg' | 'body';

const ExprPathImpl = buildValueClass('ExprPath', ['container', 'pathSteps']);

export type ExprPath = {
    container: ExprContainer,
    pathSteps: Immutable.List<PathComponent>,
    withContainer(container: ExprContainer): ExprPath,
    withPathSteps(pathSteps: Immutable.List<PathComponent>): ExprPath,
    updateContainer(updater: Updater<ExprContainer>): ExprPath,
    updatePathSteps(updater: Updater<Immutable.List<PathComponent>>): ExprPath,
    toJS(): any,
    serialize(): any,
};

export const newExprPath = (container: ExprContainer, pathSteps: Immutable.List<PathComponent>): ExprPath => (new ExprPathImpl({
    container,
    pathSteps,
}));

const ExprIdContainerImpl = buildUnionCaseClass('exprIdContainer', ['exprId']);
export type ExprIdContainer = {
    type: 'exprIdContainer',
    exprId: number,
    withExprId(exprId: number): ExprIdContainer,
    updateExprId(updater: Updater<number>): ExprIdContainer,
    match<T>(visitor: ExprContainerVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newExprIdContainer = (exprId: number): ExprIdContainer => (new ExprIdContainerImpl({
    type: 'exprIdContainer',
    exprId,
}));

const DefinitionContainerImpl = buildUnionCaseClass('definitionContainer', ['defName']);
export type DefinitionContainer = {
    type: 'definitionContainer',
    defName: string,
    withDefName(defName: string): DefinitionContainer,
    updateDefName(updater: Updater<string>): DefinitionContainer,
    match<T>(visitor: ExprContainerVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDefinitionContainer = (defName: string): DefinitionContainer => (new DefinitionContainerImpl({
    type: 'definitionContainer',
    defName,
}));

export type ExprContainer = ExprIdContainer | DefinitionContainer;

export type ExprContainerVisitor<T> = {
    exprIdContainer(exprIdContainer: ExprIdContainer): T,
    definitionContainer(definitionContainer: DefinitionContainer): T,
}

const PickUpExpressionImpl = buildUnionCaseClass('pickUpExpression', ['exprId', 'offset', 'screenRect']);
export type PickUpExpression = {
    type: 'pickUpExpression',
    exprId: number,
    offset: PointDifference,
    screenRect: ScreenRect,
    withExprId(exprId: number): PickUpExpression,
    withOffset(offset: PointDifference): PickUpExpression,
    withScreenRect(screenRect: ScreenRect): PickUpExpression,
    updateExprId(updater: Updater<number>): PickUpExpression,
    updateOffset(updater: Updater<PointDifference>): PickUpExpression,
    updateScreenRect(updater: Updater<ScreenRect>): PickUpExpression,
    match<T>(visitor: DragResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newPickUpExpression = (exprId: number, offset: PointDifference, screenRect: ScreenRect): PickUpExpression => (new PickUpExpressionImpl({
    type: 'pickUpExpression',
    exprId,
    offset,
    screenRect,
}));

const DecomposeExpressionImpl = buildUnionCaseClass('decomposeExpression', ['exprPath', 'offset', 'screenRect']);
export type DecomposeExpression = {
    type: 'decomposeExpression',
    exprPath: ExprPath,
    offset: PointDifference,
    screenRect: ScreenRect,
    withExprPath(exprPath: ExprPath): DecomposeExpression,
    withOffset(offset: PointDifference): DecomposeExpression,
    withScreenRect(screenRect: ScreenRect): DecomposeExpression,
    updateExprPath(updater: Updater<ExprPath>): DecomposeExpression,
    updateOffset(updater: Updater<PointDifference>): DecomposeExpression,
    updateScreenRect(updater: Updater<ScreenRect>): DecomposeExpression,
    match<T>(visitor: DragResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDecomposeExpression = (exprPath: ExprPath, offset: PointDifference, screenRect: ScreenRect): DecomposeExpression => (new DecomposeExpressionImpl({
    type: 'decomposeExpression',
    exprPath,
    offset,
    screenRect,
}));

const CreateExpressionImpl = buildUnionCaseClass('createExpression', ['expr', 'offset', 'screenRect']);
export type CreateExpression = {
    type: 'createExpression',
    expr: UserExpression,
    offset: PointDifference,
    screenRect: ScreenRect,
    withExpr(expr: UserExpression): CreateExpression,
    withOffset(offset: PointDifference): CreateExpression,
    withScreenRect(screenRect: ScreenRect): CreateExpression,
    updateExpr(updater: Updater<UserExpression>): CreateExpression,
    updateOffset(updater: Updater<PointDifference>): CreateExpression,
    updateScreenRect(updater: Updater<ScreenRect>): CreateExpression,
    match<T>(visitor: DragResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newCreateExpression = (expr: UserExpression, offset: PointDifference, screenRect: ScreenRect): CreateExpression => (new CreateExpressionImpl({
    type: 'createExpression',
    expr,
    offset,
    screenRect,
}));

const StartPanImpl = buildUnionCaseClass('startPan', ['startPos']);
export type StartPan = {
    type: 'startPan',
    startPos: ScreenPoint,
    withStartPos(startPos: ScreenPoint): StartPan,
    updateStartPos(updater: Updater<ScreenPoint>): StartPan,
    match<T>(visitor: DragResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newStartPan = (startPos: ScreenPoint): StartPan => (new StartPanImpl({
    type: 'startPan',
    startPos,
}));

export type DragResult = PickUpExpression | DecomposeExpression | CreateExpression | StartPan;

export type DragResultVisitor<T> = {
    pickUpExpression(pickUpExpression: PickUpExpression): T,
    decomposeExpression(decomposeExpression: DecomposeExpression): T,
    createExpression(createExpression: CreateExpression): T,
    startPan(startPan: StartPan): T,
}

const DragDataImpl = buildValueClass('DragData', ['userExpr', 'grabOffset', 'screenRect']);

export type DragData = {
    userExpr: UserExpression,
    grabOffset: PointDifference,
    screenRect: ScreenRect,
    withUserExpr(userExpr: UserExpression): DragData,
    withGrabOffset(grabOffset: PointDifference): DragData,
    withScreenRect(screenRect: ScreenRect): DragData,
    updateUserExpr(updater: Updater<UserExpression>): DragData,
    updateGrabOffset(updater: Updater<PointDifference>): DragData,
    updateScreenRect(updater: Updater<ScreenRect>): DragData,
    toJS(): any,
    serialize(): any,
};

export const newDragData = (userExpr: UserExpression, grabOffset: PointDifference, screenRect: ScreenRect): DragData => (new DragDataImpl({
    userExpr,
    grabOffset,
    screenRect,
}));

const AddToTopLevelResultImpl = buildUnionCaseClass('addToTopLevelResult', ['expr', 'screenPos']);
export type AddToTopLevelResult = {
    type: 'addToTopLevelResult',
    expr: UserExpression,
    screenPos: ScreenPoint,
    withExpr(expr: UserExpression): AddToTopLevelResult,
    withScreenPos(screenPos: ScreenPoint): AddToTopLevelResult,
    updateExpr(updater: Updater<UserExpression>): AddToTopLevelResult,
    updateScreenPos(updater: Updater<ScreenPoint>): AddToTopLevelResult,
    match<T>(visitor: DropResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newAddToTopLevelResult = (expr: UserExpression, screenPos: ScreenPoint): AddToTopLevelResult => (new AddToTopLevelResultImpl({
    type: 'addToTopLevelResult',
    expr,
    screenPos,
}));

const InsertAsBodyResultImpl = buildUnionCaseClass('insertAsBodyResult', ['lambdaPath', 'expr']);
export type InsertAsBodyResult = {
    type: 'insertAsBodyResult',
    lambdaPath: ExprPath,
    expr: UserExpression,
    withLambdaPath(lambdaPath: ExprPath): InsertAsBodyResult,
    withExpr(expr: UserExpression): InsertAsBodyResult,
    updateLambdaPath(updater: Updater<ExprPath>): InsertAsBodyResult,
    updateExpr(updater: Updater<UserExpression>): InsertAsBodyResult,
    match<T>(visitor: DropResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newInsertAsBodyResult = (lambdaPath: ExprPath, expr: UserExpression): InsertAsBodyResult => (new InsertAsBodyResultImpl({
    type: 'insertAsBodyResult',
    lambdaPath,
    expr,
}));

const InsertAsArgResultImpl = buildUnionCaseClass('insertAsArgResult', ['path', 'expr']);
export type InsertAsArgResult = {
    type: 'insertAsArgResult',
    path: ExprPath,
    expr: UserExpression,
    withPath(path: ExprPath): InsertAsArgResult,
    withExpr(expr: UserExpression): InsertAsArgResult,
    updatePath(updater: Updater<ExprPath>): InsertAsArgResult,
    updateExpr(updater: Updater<UserExpression>): InsertAsArgResult,
    match<T>(visitor: DropResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newInsertAsArgResult = (path: ExprPath, expr: UserExpression): InsertAsArgResult => (new InsertAsArgResultImpl({
    type: 'insertAsArgResult',
    path,
    expr,
}));

const RemoveResultImpl = buildUnionCaseClass('removeResult', []);
export type RemoveResult = {
    type: 'removeResult',
    match<T>(visitor: DropResultVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newRemoveResult = (): RemoveResult => (new RemoveResultImpl({
    type: 'removeResult',
}));

export type DropResult = AddToTopLevelResult | InsertAsBodyResult | InsertAsArgResult | RemoveResult;

export type DropResultVisitor<T> = {
    addToTopLevelResult(addToTopLevelResult: AddToTopLevelResult): T,
    insertAsBodyResult(insertAsBodyResult: InsertAsBodyResult): T,
    insertAsArgResult(insertAsArgResult: InsertAsArgResult): T,
    removeResult(removeResult: RemoveResult): T,
}

const ExpressionKeyImpl = buildUnionCaseClass('expressionKey', ['exprPath']);
export type ExpressionKey = {
    type: 'expressionKey',
    exprPath: ExprPath,
    withExprPath(exprPath: ExprPath): ExpressionKey,
    updateExprPath(updater: Updater<ExprPath>): ExpressionKey,
    match<T>(visitor: ViewKeyVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newExpressionKey = (exprPath: ExprPath): ExpressionKey => (new ExpressionKeyImpl({
    type: 'expressionKey',
    exprPath,
}));

const EmptyBodyKeyImpl = buildUnionCaseClass('emptyBodyKey', ['lambdaPath']);
export type EmptyBodyKey = {
    type: 'emptyBodyKey',
    lambdaPath: ExprPath,
    withLambdaPath(lambdaPath: ExprPath): EmptyBodyKey,
    updateLambdaPath(updater: Updater<ExprPath>): EmptyBodyKey,
    match<T>(visitor: ViewKeyVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newEmptyBodyKey = (lambdaPath: ExprPath): EmptyBodyKey => (new EmptyBodyKeyImpl({
    type: 'emptyBodyKey',
    lambdaPath,
}));

const LambdaVarKeyImpl = buildUnionCaseClass('lambdaVarKey', ['lambdaPath']);
export type LambdaVarKey = {
    type: 'lambdaVarKey',
    lambdaPath: ExprPath,
    withLambdaPath(lambdaPath: ExprPath): LambdaVarKey,
    updateLambdaPath(updater: Updater<ExprPath>): LambdaVarKey,
    match<T>(visitor: ViewKeyVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newLambdaVarKey = (lambdaPath: ExprPath): LambdaVarKey => (new LambdaVarKeyImpl({
    type: 'lambdaVarKey',
    lambdaPath,
}));

const DefinitionKeyImpl = buildUnionCaseClass('definitionKey', ['defName']);
export type DefinitionKey = {
    type: 'definitionKey',
    defName: string,
    withDefName(defName: string): DefinitionKey,
    updateDefName(updater: Updater<string>): DefinitionKey,
    match<T>(visitor: ViewKeyVisitor<T>): T,
    toJS(): any,
    serialize(): any,
};

export const newDefinitionKey = (defName: string): DefinitionKey => (new DefinitionKeyImpl({
    type: 'definitionKey',
    defName,
}));

export type ViewKey = ExpressionKey | EmptyBodyKey | LambdaVarKey | DefinitionKey;

export type ViewKeyVisitor<T> = {
    expressionKey(expressionKey: ExpressionKey): T,
    emptyBodyKey(emptyBodyKey: EmptyBodyKey): T,
    lambdaVarKey(lambdaVarKey: LambdaVarKey): T,
    definitionKey(definitionKey: DefinitionKey): T,
}

