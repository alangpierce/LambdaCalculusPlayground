/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 *
 * @flow
 */
export type UserLambda = {
    type: 'userLambda',
    varName: string,
    body: ?UserExpression,
};

export const newUserLambda = (varName: string, body: ?UserExpression) => ({
    type: 'userLambda',
    varName,
    body,
});

export type UserFuncCall = {
    type: 'userFuncCall',
    func: UserExpression,
    arg: UserExpression,
};

export const newUserFuncCall = (func: UserExpression, arg: UserExpression) => ({
    type: 'userFuncCall',
    func,
    arg,
});

export type UserVariable = {
    type: 'userVariable',
    varName: string,
};

export const newUserVariable = (varName: string) => ({
    type: 'userVariable',
    varName,
});

export type UserReference = {
    type: 'userReference',
    defName: string,
};

export const newUserReference = (defName: string) => ({
    type: 'userReference',
    defName,
});

export type UserExpression = UserLambda | UserFuncCall | UserVariable | UserReference;

export type UserExpressionVisitor<T> = {
    userLambda: (userLambda: UserLambda) => T,
    userFuncCall: (userFuncCall: UserFuncCall) => T,
    userVariable: (userVariable: UserVariable) => T,
    userReference: (userReference: UserReference) => T,
}

export const matchUserExpression = function<T>(userExpression: UserExpression, visitor: UserExpressionVisitor<T>): T {
    switch (userExpression.type) {
        case 'userLambda':
            return visitor.userLambda(userExpression);
        case 'userFuncCall':
            return visitor.userFuncCall(userExpression);
        case 'userVariable':
            return visitor.userVariable(userExpression);
        case 'userReference':
            return visitor.userReference(userExpression);
        default:
            throw new Error('Unexpected type: ' + userExpression.type);
    }
};

export type ScreenExpression = {
    expr: UserExpression,
    pos: CanvasPoint,
};

export const newScreenExpression = (expr: UserExpression, pos: CanvasPoint) => ({
    expr,
    pos,
});

export type CanvasPoint = {
    canvasX: number,
    canvasY: number,
};

export const newCanvasPoint = (canvasX: number, canvasY: number) => ({
    canvasX,
    canvasY,
});

export type PathComponent = 'func' | 'arg' | 'body';

export type ExprPath = {
    exprId: number,
    pathSteps: Array<PathComponent>,
};

export const newExprPath = (exprId: number, pathSteps: Array<PathComponent>) => ({
    exprId,
    pathSteps,
});

