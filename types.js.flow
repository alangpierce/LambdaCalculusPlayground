/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 *
 * @flow
 */
 
import {IList, IMap, ISet} from './types-collections'
import {buildUnionCaseClass, buildValueClass} from './types-lib'
import type {Updater} from './types-lib'

declare export class State {
    canvasExpressions: IMap<number, CanvasExpression>;
    nextExprId: number;
    canvasDefinitions: IMap<string, CanvasPoint>;
    definitions: IMap<string, ?UserExpression>;
    pendingResults: IMap<number, PendingResult>;
    activeDrags: IMap<number, DragData>;
    highlightedExprs: ISet<ExprPath>;
    highlightedEmptyBodies: ISet<ExprPath>;
    withCanvasExpressions(canvasExpressions: IMap<number, CanvasExpression>): State;
    withNextExprId(nextExprId: number): State;
    withCanvasDefinitions(canvasDefinitions: IMap<string, CanvasPoint>): State;
    withDefinitions(definitions: IMap<string, ?UserExpression>): State;
    withPendingResults(pendingResults: IMap<number, PendingResult>): State;
    withActiveDrags(activeDrags: IMap<number, DragData>): State;
    withHighlightedExprs(highlightedExprs: ISet<ExprPath>): State;
    withHighlightedEmptyBodies(highlightedEmptyBodies: ISet<ExprPath>): State;
    updateCanvasExpressions(updater: Updater<IMap<number, CanvasExpression>>): State;
    updateNextExprId(updater: Updater<number>): State;
    updateCanvasDefinitions(updater: Updater<IMap<string, CanvasPoint>>): State;
    updateDefinitions(updater: Updater<IMap<string, ?UserExpression>>): State;
    updatePendingResults(updater: Updater<IMap<number, PendingResult>>): State;
    updateActiveDrags(updater: Updater<IMap<number, DragData>>): State;
    updateHighlightedExprs(updater: Updater<ISet<ExprPath>>): State;
    updateHighlightedEmptyBodies(updater: Updater<ISet<ExprPath>>): State;
    toJS(): any;
    serialize(): any;
};

export const newState = (canvasExpressions: IMap<number, CanvasExpression>, nextExprId: number, canvasDefinitions: IMap<string, CanvasPoint>, definitions: IMap<string, ?UserExpression>, pendingResults: IMap<number, PendingResult>, activeDrags: IMap<number, DragData>, highlightedExprs: ISet<ExprPath>, highlightedEmptyBodies: ISet<ExprPath>): State => (new State({
    canvasExpressions,
    nextExprId,
    canvasDefinitions,
    definitions,
    pendingResults,
    activeDrags,
    highlightedExprs,
    highlightedEmptyBodies,
}));

declare export class Reset {
    type: 'reset';
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newReset = (): Reset => (new Reset({
    type: 'reset',
}));

declare export class AddExpression {
    type: 'addExpression';
    canvasExpr: CanvasExpression;
    withCanvasExpr(canvasExpr: CanvasExpression): AddExpression;
    updateCanvasExpr(updater: Updater<CanvasExpression>): AddExpression;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newAddExpression = (canvasExpr: CanvasExpression): AddExpression => (new AddExpression({
    type: 'addExpression',
    canvasExpr,
}));

declare export class PlaceDefinition {
    type: 'placeDefinition';
    defName: string;
    screenPos: ScreenPoint;
    withDefName(defName: string): PlaceDefinition;
    withScreenPos(screenPos: ScreenPoint): PlaceDefinition;
    updateDefName(updater: Updater<string>): PlaceDefinition;
    updateScreenPos(updater: Updater<ScreenPoint>): PlaceDefinition;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newPlaceDefinition = (defName: string, screenPos: ScreenPoint): PlaceDefinition => (new PlaceDefinition({
    type: 'placeDefinition',
    defName,
    screenPos,
}));

declare export class MoveExpression {
    type: 'moveExpression';
    exprId: number;
    pos: CanvasPoint;
    withExprId(exprId: number): MoveExpression;
    withPos(pos: CanvasPoint): MoveExpression;
    updateExprId(updater: Updater<number>): MoveExpression;
    updatePos(updater: Updater<CanvasPoint>): MoveExpression;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newMoveExpression = (exprId: number, pos: CanvasPoint): MoveExpression => (new MoveExpression({
    type: 'moveExpression',
    exprId,
    pos,
}));

declare export class DecomposeExpressionAction {
    type: 'decomposeExpressionAction';
    path: ExprPath;
    targetPos: CanvasPoint;
    withPath(path: ExprPath): DecomposeExpressionAction;
    withTargetPos(targetPos: CanvasPoint): DecomposeExpressionAction;
    updatePath(updater: Updater<ExprPath>): DecomposeExpressionAction;
    updateTargetPos(updater: Updater<CanvasPoint>): DecomposeExpressionAction;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDecomposeExpressionAction = (path: ExprPath, targetPos: CanvasPoint): DecomposeExpressionAction => (new DecomposeExpressionAction({
    type: 'decomposeExpressionAction',
    path,
    targetPos,
}));

declare export class InsertAsArg {
    type: 'insertAsArg';
    argExprId: number;
    path: ExprPath;
    withArgExprId(argExprId: number): InsertAsArg;
    withPath(path: ExprPath): InsertAsArg;
    updateArgExprId(updater: Updater<number>): InsertAsArg;
    updatePath(updater: Updater<ExprPath>): InsertAsArg;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newInsertAsArg = (argExprId: number, path: ExprPath): InsertAsArg => (new InsertAsArg({
    type: 'insertAsArg',
    argExprId,
    path,
}));

declare export class InsertAsBody {
    type: 'insertAsBody';
    bodyExprId: number;
    path: ExprPath;
    withBodyExprId(bodyExprId: number): InsertAsBody;
    withPath(path: ExprPath): InsertAsBody;
    updateBodyExprId(updater: Updater<number>): InsertAsBody;
    updatePath(updater: Updater<ExprPath>): InsertAsBody;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newInsertAsBody = (bodyExprId: number, path: ExprPath): InsertAsBody => (new InsertAsBody({
    type: 'insertAsBody',
    bodyExprId,
    path,
}));

declare export class EvaluateExpression {
    type: 'evaluateExpression';
    exprId: number;
    withExprId(exprId: number): EvaluateExpression;
    updateExprId(updater: Updater<number>): EvaluateExpression;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newEvaluateExpression = (exprId: number): EvaluateExpression => (new EvaluateExpression({
    type: 'evaluateExpression',
    exprId,
}));

declare export class PlacePendingResult {
    type: 'placePendingResult';
    exprId: number;
    width: number;
    height: number;
    withExprId(exprId: number): PlacePendingResult;
    withWidth(width: number): PlacePendingResult;
    withHeight(height: number): PlacePendingResult;
    updateExprId(updater: Updater<number>): PlacePendingResult;
    updateWidth(updater: Updater<number>): PlacePendingResult;
    updateHeight(updater: Updater<number>): PlacePendingResult;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newPlacePendingResult = (exprId: number, width: number, height: number): PlacePendingResult => (new PlacePendingResult({
    type: 'placePendingResult',
    exprId,
    width,
    height,
}));

declare export class FingerDown {
    type: 'fingerDown';
    fingerId: number;
    screenPos: ScreenPoint;
    withFingerId(fingerId: number): FingerDown;
    withScreenPos(screenPos: ScreenPoint): FingerDown;
    updateFingerId(updater: Updater<number>): FingerDown;
    updateScreenPos(updater: Updater<ScreenPoint>): FingerDown;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newFingerDown = (fingerId: number, screenPos: ScreenPoint): FingerDown => (new FingerDown({
    type: 'fingerDown',
    fingerId,
    screenPos,
}));

declare export class FingerMove {
    type: 'fingerMove';
    fingerId: number;
    screenPos: ScreenPoint;
    withFingerId(fingerId: number): FingerMove;
    withScreenPos(screenPos: ScreenPoint): FingerMove;
    updateFingerId(updater: Updater<number>): FingerMove;
    updateScreenPos(updater: Updater<ScreenPoint>): FingerMove;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newFingerMove = (fingerId: number, screenPos: ScreenPoint): FingerMove => (new FingerMove({
    type: 'fingerMove',
    fingerId,
    screenPos,
}));

declare export class FingerUp {
    type: 'fingerUp';
    fingerId: number;
    screenPos: ScreenPoint;
    withFingerId(fingerId: number): FingerUp;
    withScreenPos(screenPos: ScreenPoint): FingerUp;
    updateFingerId(updater: Updater<number>): FingerUp;
    updateScreenPos(updater: Updater<ScreenPoint>): FingerUp;
    match<T>(visitor: ActionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newFingerUp = (fingerId: number, screenPos: ScreenPoint): FingerUp => (new FingerUp({
    type: 'fingerUp',
    fingerId,
    screenPos,
}));

export type Action = Reset | AddExpression | PlaceDefinition | MoveExpression | DecomposeExpressionAction | InsertAsArg | InsertAsBody | EvaluateExpression | PlacePendingResult | FingerDown | FingerMove | FingerUp;

export type ActionVisitor<T> = {
    reset(reset: Reset): T,
    addExpression(addExpression: AddExpression): T,
    placeDefinition(placeDefinition: PlaceDefinition): T,
    moveExpression(moveExpression: MoveExpression): T,
    decomposeExpressionAction(decomposeExpressionAction: DecomposeExpressionAction): T,
    insertAsArg(insertAsArg: InsertAsArg): T,
    insertAsBody(insertAsBody: InsertAsBody): T,
    evaluateExpression(evaluateExpression: EvaluateExpression): T,
    placePendingResult(placePendingResult: PlacePendingResult): T,
    fingerDown(fingerDown: FingerDown): T,
    fingerMove(fingerMove: FingerMove): T,
    fingerUp(fingerUp: FingerUp): T,
}

declare export class Lambda {
    type: 'lambda';
    varName: string;
    body: Expression;
    withVarName(varName: string): Lambda;
    withBody(body: Expression): Lambda;
    updateVarName(updater: Updater<string>): Lambda;
    updateBody(updater: Updater<Expression>): Lambda;
    match<T>(visitor: ExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newLambda = (varName: string, body: Expression): Lambda => (new Lambda({
    type: 'lambda',
    varName,
    body,
}));

declare export class FuncCall {
    type: 'funcCall';
    func: Expression;
    arg: Expression;
    withFunc(func: Expression): FuncCall;
    withArg(arg: Expression): FuncCall;
    updateFunc(updater: Updater<Expression>): FuncCall;
    updateArg(updater: Updater<Expression>): FuncCall;
    match<T>(visitor: ExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newFuncCall = (func: Expression, arg: Expression): FuncCall => (new FuncCall({
    type: 'funcCall',
    func,
    arg,
}));

declare export class Variable {
    type: 'variable';
    varName: string;
    withVarName(varName: string): Variable;
    updateVarName(updater: Updater<string>): Variable;
    match<T>(visitor: ExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newVariable = (varName: string): Variable => (new Variable({
    type: 'variable',
    varName,
}));

export type Expression = Lambda | FuncCall | Variable;

export type ExpressionVisitor<T> = {
    lambda(lambda: Lambda): T,
    funcCall(funcCall: FuncCall): T,
    variable(variable: Variable): T,
}

export type Slot = {
    isValue: boolean,
    expr: EvalExpression,
    originalVarName: string
};

export type VarMarker = number;

declare export class EvalLambda {
    type: 'evalLambda';
    varMarker: VarMarker;
    originalVarName: string;
    body: EvalExpression;
    withVarMarker(varMarker: VarMarker): EvalLambda;
    withOriginalVarName(originalVarName: string): EvalLambda;
    withBody(body: EvalExpression): EvalLambda;
    updateVarMarker(updater: Updater<VarMarker>): EvalLambda;
    updateOriginalVarName(updater: Updater<string>): EvalLambda;
    updateBody(updater: Updater<EvalExpression>): EvalLambda;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newEvalLambda = (varMarker: VarMarker, originalVarName: string, body: EvalExpression): EvalLambda => (new EvalLambda({
    type: 'evalLambda',
    varMarker,
    originalVarName,
    body,
}));

declare export class EvalFuncCall {
    type: 'evalFuncCall';
    func: EvalExpression;
    arg: EvalExpression;
    withFunc(func: EvalExpression): EvalFuncCall;
    withArg(arg: EvalExpression): EvalFuncCall;
    updateFunc(updater: Updater<EvalExpression>): EvalFuncCall;
    updateArg(updater: Updater<EvalExpression>): EvalFuncCall;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newEvalFuncCall = (func: EvalExpression, arg: EvalExpression): EvalFuncCall => (new EvalFuncCall({
    type: 'evalFuncCall',
    func,
    arg,
}));

declare export class EvalBoundVariable {
    type: 'evalBoundVariable';
    slot: Slot;
    withSlot(slot: Slot): EvalBoundVariable;
    updateSlot(updater: Updater<Slot>): EvalBoundVariable;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newEvalBoundVariable = (slot: Slot): EvalBoundVariable => (new EvalBoundVariable({
    type: 'evalBoundVariable',
    slot,
}));

declare export class EvalUnboundVariable {
    type: 'evalUnboundVariable';
    varMarker: VarMarker;
    originalVarName: string;
    withVarMarker(varMarker: VarMarker): EvalUnboundVariable;
    withOriginalVarName(originalVarName: string): EvalUnboundVariable;
    updateVarMarker(updater: Updater<VarMarker>): EvalUnboundVariable;
    updateOriginalVarName(updater: Updater<string>): EvalUnboundVariable;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newEvalUnboundVariable = (varMarker: VarMarker, originalVarName: string): EvalUnboundVariable => (new EvalUnboundVariable({
    type: 'evalUnboundVariable',
    varMarker,
    originalVarName,
}));

declare export class EvalFreeVariable {
    type: 'evalFreeVariable';
    varName: string;
    withVarName(varName: string): EvalFreeVariable;
    updateVarName(updater: Updater<string>): EvalFreeVariable;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newEvalFreeVariable = (varName: string): EvalFreeVariable => (new EvalFreeVariable({
    type: 'evalFreeVariable',
    varName,
}));

export type EvalExpression = EvalLambda | EvalFuncCall | EvalBoundVariable | EvalUnboundVariable | EvalFreeVariable;

export type EvalExpressionVisitor<T> = {
    evalLambda(evalLambda: EvalLambda): T,
    evalFuncCall(evalFuncCall: EvalFuncCall): T,
    evalBoundVariable(evalBoundVariable: EvalBoundVariable): T,
    evalUnboundVariable(evalUnboundVariable: EvalUnboundVariable): T,
    evalFreeVariable(evalFreeVariable: EvalFreeVariable): T,
}

declare export class UserLambda {
    type: 'userLambda';
    varName: string;
    body: ?UserExpression;
    withVarName(varName: string): UserLambda;
    withBody(body: ?UserExpression): UserLambda;
    updateVarName(updater: Updater<string>): UserLambda;
    updateBody(updater: Updater<?UserExpression>): UserLambda;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newUserLambda = (varName: string, body: ?UserExpression): UserLambda => (new UserLambda({
    type: 'userLambda',
    varName,
    body,
}));

declare export class UserFuncCall {
    type: 'userFuncCall';
    func: UserExpression;
    arg: UserExpression;
    withFunc(func: UserExpression): UserFuncCall;
    withArg(arg: UserExpression): UserFuncCall;
    updateFunc(updater: Updater<UserExpression>): UserFuncCall;
    updateArg(updater: Updater<UserExpression>): UserFuncCall;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newUserFuncCall = (func: UserExpression, arg: UserExpression): UserFuncCall => (new UserFuncCall({
    type: 'userFuncCall',
    func,
    arg,
}));

declare export class UserVariable {
    type: 'userVariable';
    varName: string;
    withVarName(varName: string): UserVariable;
    updateVarName(updater: Updater<string>): UserVariable;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newUserVariable = (varName: string): UserVariable => (new UserVariable({
    type: 'userVariable',
    varName,
}));

declare export class UserReference {
    type: 'userReference';
    defName: string;
    withDefName(defName: string): UserReference;
    updateDefName(updater: Updater<string>): UserReference;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newUserReference = (defName: string): UserReference => (new UserReference({
    type: 'userReference',
    defName,
}));

export type UserExpression = UserLambda | UserFuncCall | UserVariable | UserReference;

export type UserExpressionVisitor<T> = {
    userLambda(userLambda: UserLambda): T,
    userFuncCall(userFuncCall: UserFuncCall): T,
    userVariable(userVariable: UserVariable): T,
    userReference(userReference: UserReference): T,
}

declare export class CanvasExpression {
    expr: UserExpression;
    pos: CanvasPoint;
    withExpr(expr: UserExpression): CanvasExpression;
    withPos(pos: CanvasPoint): CanvasExpression;
    updateExpr(updater: Updater<UserExpression>): CanvasExpression;
    updatePos(updater: Updater<CanvasPoint>): CanvasExpression;
    toJS(): any;
    serialize(): any;
};

export const newCanvasExpression = (expr: UserExpression, pos: CanvasPoint): CanvasExpression => (new CanvasExpression({
    expr,
    pos,
}));

declare export class PendingResult {
    expr: UserExpression;
    sourceExprId: number;
    withExpr(expr: UserExpression): PendingResult;
    withSourceExprId(sourceExprId: number): PendingResult;
    updateExpr(updater: Updater<UserExpression>): PendingResult;
    updateSourceExprId(updater: Updater<number>): PendingResult;
    toJS(): any;
    serialize(): any;
};

export const newPendingResult = (expr: UserExpression, sourceExprId: number): PendingResult => (new PendingResult({
    expr,
    sourceExprId,
}));

declare export class DisplayState {
    screenExpressions: IList<ScreenExpression>;
    screenDefinitions: IList<ScreenDefinition>;
    measureRequests: IList<MeasureRequest>;
    withScreenExpressions(screenExpressions: IList<ScreenExpression>): DisplayState;
    withScreenDefinitions(screenDefinitions: IList<ScreenDefinition>): DisplayState;
    withMeasureRequests(measureRequests: IList<MeasureRequest>): DisplayState;
    updateScreenExpressions(updater: Updater<IList<ScreenExpression>>): DisplayState;
    updateScreenDefinitions(updater: Updater<IList<ScreenDefinition>>): DisplayState;
    updateMeasureRequests(updater: Updater<IList<MeasureRequest>>): DisplayState;
    toJS(): any;
    serialize(): any;
};

export const newDisplayState = (screenExpressions: IList<ScreenExpression>, screenDefinitions: IList<ScreenDefinition>, measureRequests: IList<MeasureRequest>): DisplayState => (new DisplayState({
    screenExpressions,
    screenDefinitions,
    measureRequests,
}));

declare export class MeasureRequest {
    expr: DisplayExpression;
    resultHandler: (width: number, height: number) => void;
    withExpr(expr: DisplayExpression): MeasureRequest;
    withResultHandler(resultHandler: (width: number, height: number) => void): MeasureRequest;
    updateExpr(updater: Updater<DisplayExpression>): MeasureRequest;
    updateResultHandler(updater: Updater<(width: number, height: number) => void>): MeasureRequest;
    toJS(): any;
    serialize(): any;
};

export const newMeasureRequest = (expr: DisplayExpression, resultHandler: (width: number, height: number) => void): MeasureRequest => (new MeasureRequest({
    expr,
    resultHandler,
}));

declare export class ScreenDefinition {
    defName: string;
    expr: ?DisplayExpression;
    pos: ScreenPoint;
    key: string;
    isDragging: boolean;
    withDefName(defName: string): ScreenDefinition;
    withExpr(expr: ?DisplayExpression): ScreenDefinition;
    withPos(pos: ScreenPoint): ScreenDefinition;
    withKey(key: string): ScreenDefinition;
    withIsDragging(isDragging: boolean): ScreenDefinition;
    updateDefName(updater: Updater<string>): ScreenDefinition;
    updateExpr(updater: Updater<?DisplayExpression>): ScreenDefinition;
    updatePos(updater: Updater<ScreenPoint>): ScreenDefinition;
    updateKey(updater: Updater<string>): ScreenDefinition;
    updateIsDragging(updater: Updater<boolean>): ScreenDefinition;
    toJS(): any;
    serialize(): any;
};

export const newScreenDefinition = (defName: string, expr: ?DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean): ScreenDefinition => (new ScreenDefinition({
    defName,
    expr,
    pos,
    key,
    isDragging,
}));

declare export class ScreenExpression {
    expr: DisplayExpression;
    pos: ScreenPoint;
    key: string;
    isDragging: boolean;
    executeHandler: ?() => void;
    withExpr(expr: DisplayExpression): ScreenExpression;
    withPos(pos: ScreenPoint): ScreenExpression;
    withKey(key: string): ScreenExpression;
    withIsDragging(isDragging: boolean): ScreenExpression;
    withExecuteHandler(executeHandler: ?() => void): ScreenExpression;
    updateExpr(updater: Updater<DisplayExpression>): ScreenExpression;
    updatePos(updater: Updater<ScreenPoint>): ScreenExpression;
    updateKey(updater: Updater<string>): ScreenExpression;
    updateIsDragging(updater: Updater<boolean>): ScreenExpression;
    updateExecuteHandler(updater: Updater<?() => void>): ScreenExpression;
    toJS(): any;
    serialize(): any;
};

export const newScreenExpression = (expr: DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean, executeHandler: ?() => void): ScreenExpression => (new ScreenExpression({
    expr,
    pos,
    key,
    isDragging,
    executeHandler,
}));

declare export class DisplayLambda {
    type: 'displayLambda';
    exprKey: ?ExpressionKey;
    shouldHighlight: boolean;
    varKey: ?LambdaVarKey;
    emptyBodyKey: ?EmptyBodyKey;
    shouldHighlightEmptyBody: boolean;
    varName: string;
    body: ?DisplayExpression;
    withExprKey(exprKey: ?ExpressionKey): DisplayLambda;
    withShouldHighlight(shouldHighlight: boolean): DisplayLambda;
    withVarKey(varKey: ?LambdaVarKey): DisplayLambda;
    withEmptyBodyKey(emptyBodyKey: ?EmptyBodyKey): DisplayLambda;
    withShouldHighlightEmptyBody(shouldHighlightEmptyBody: boolean): DisplayLambda;
    withVarName(varName: string): DisplayLambda;
    withBody(body: ?DisplayExpression): DisplayLambda;
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayLambda;
    updateShouldHighlight(updater: Updater<boolean>): DisplayLambda;
    updateVarKey(updater: Updater<?LambdaVarKey>): DisplayLambda;
    updateEmptyBodyKey(updater: Updater<?EmptyBodyKey>): DisplayLambda;
    updateShouldHighlightEmptyBody(updater: Updater<boolean>): DisplayLambda;
    updateVarName(updater: Updater<string>): DisplayLambda;
    updateBody(updater: Updater<?DisplayExpression>): DisplayLambda;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDisplayLambda = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varKey: ?LambdaVarKey, emptyBodyKey: ?EmptyBodyKey, shouldHighlightEmptyBody: boolean, varName: string, body: ?DisplayExpression): DisplayLambda => (new DisplayLambda({
    type: 'displayLambda',
    exprKey,
    shouldHighlight,
    varKey,
    emptyBodyKey,
    shouldHighlightEmptyBody,
    varName,
    body,
}));

declare export class DisplayFuncCall {
    type: 'displayFuncCall';
    exprKey: ?ExpressionKey;
    shouldHighlight: boolean;
    func: DisplayExpression;
    arg: DisplayExpression;
    withExprKey(exprKey: ?ExpressionKey): DisplayFuncCall;
    withShouldHighlight(shouldHighlight: boolean): DisplayFuncCall;
    withFunc(func: DisplayExpression): DisplayFuncCall;
    withArg(arg: DisplayExpression): DisplayFuncCall;
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayFuncCall;
    updateShouldHighlight(updater: Updater<boolean>): DisplayFuncCall;
    updateFunc(updater: Updater<DisplayExpression>): DisplayFuncCall;
    updateArg(updater: Updater<DisplayExpression>): DisplayFuncCall;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDisplayFuncCall = (exprKey: ?ExpressionKey, shouldHighlight: boolean, func: DisplayExpression, arg: DisplayExpression): DisplayFuncCall => (new DisplayFuncCall({
    type: 'displayFuncCall',
    exprKey,
    shouldHighlight,
    func,
    arg,
}));

declare export class DisplayVariable {
    type: 'displayVariable';
    exprKey: ?ExpressionKey;
    shouldHighlight: boolean;
    varName: string;
    withExprKey(exprKey: ?ExpressionKey): DisplayVariable;
    withShouldHighlight(shouldHighlight: boolean): DisplayVariable;
    withVarName(varName: string): DisplayVariable;
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayVariable;
    updateShouldHighlight(updater: Updater<boolean>): DisplayVariable;
    updateVarName(updater: Updater<string>): DisplayVariable;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDisplayVariable = (exprKey: ?ExpressionKey, shouldHighlight: boolean, varName: string): DisplayVariable => (new DisplayVariable({
    type: 'displayVariable',
    exprKey,
    shouldHighlight,
    varName,
}));

declare export class DisplayReference {
    type: 'displayReference';
    exprKey: ?ExpressionKey;
    shouldHighlight: boolean;
    defName: string;
    withExprKey(exprKey: ?ExpressionKey): DisplayReference;
    withShouldHighlight(shouldHighlight: boolean): DisplayReference;
    withDefName(defName: string): DisplayReference;
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayReference;
    updateShouldHighlight(updater: Updater<boolean>): DisplayReference;
    updateDefName(updater: Updater<string>): DisplayReference;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDisplayReference = (exprKey: ?ExpressionKey, shouldHighlight: boolean, defName: string): DisplayReference => (new DisplayReference({
    type: 'displayReference',
    exprKey,
    shouldHighlight,
    defName,
}));

export type DisplayExpression = DisplayLambda | DisplayFuncCall | DisplayVariable | DisplayReference;

export type DisplayExpressionVisitor<T> = {
    displayLambda(displayLambda: DisplayLambda): T,
    displayFuncCall(displayFuncCall: DisplayFuncCall): T,
    displayVariable(displayVariable: DisplayVariable): T,
    displayReference(displayReference: DisplayReference): T,
}

declare export class CanvasPoint {
    canvasX: number;
    canvasY: number;
    withCanvasX(canvasX: number): CanvasPoint;
    withCanvasY(canvasY: number): CanvasPoint;
    updateCanvasX(updater: Updater<number>): CanvasPoint;
    updateCanvasY(updater: Updater<number>): CanvasPoint;
    toJS(): any;
    serialize(): any;
};

export const newCanvasPoint = (canvasX: number, canvasY: number): CanvasPoint => (new CanvasPoint({
    canvasX,
    canvasY,
}));

declare export class PointDifference {
    dx: number;
    dy: number;
    withDx(dx: number): PointDifference;
    withDy(dy: number): PointDifference;
    updateDx(updater: Updater<number>): PointDifference;
    updateDy(updater: Updater<number>): PointDifference;
    toJS(): any;
    serialize(): any;
};

export const newPointDifference = (dx: number, dy: number): PointDifference => (new PointDifference({
    dx,
    dy,
}));

declare export class ScreenPoint {
    screenX: number;
    screenY: number;
    withScreenX(screenX: number): ScreenPoint;
    withScreenY(screenY: number): ScreenPoint;
    updateScreenX(updater: Updater<number>): ScreenPoint;
    updateScreenY(updater: Updater<number>): ScreenPoint;
    toJS(): any;
    serialize(): any;
};

export const newScreenPoint = (screenX: number, screenY: number): ScreenPoint => (new ScreenPoint({
    screenX,
    screenY,
}));

declare export class ScreenRect {
    topLeft: ScreenPoint;
    bottomRight: ScreenPoint;
    withTopLeft(topLeft: ScreenPoint): ScreenRect;
    withBottomRight(bottomRight: ScreenPoint): ScreenRect;
    updateTopLeft(updater: Updater<ScreenPoint>): ScreenRect;
    updateBottomRight(updater: Updater<ScreenPoint>): ScreenRect;
    toJS(): any;
    serialize(): any;
};

export const newScreenRect = (topLeft: ScreenPoint, bottomRight: ScreenPoint): ScreenRect => (new ScreenRect({
    topLeft,
    bottomRight,
}));

export type PathComponent = 'func' | 'arg' | 'body';

declare export class ExprPath {
    container: ExprContainer;
    pathSteps: IList<PathComponent>;
    withContainer(container: ExprContainer): ExprPath;
    withPathSteps(pathSteps: IList<PathComponent>): ExprPath;
    updateContainer(updater: Updater<ExprContainer>): ExprPath;
    updatePathSteps(updater: Updater<IList<PathComponent>>): ExprPath;
    toJS(): any;
    serialize(): any;
};

export const newExprPath = (container: ExprContainer, pathSteps: IList<PathComponent>): ExprPath => (new ExprPath({
    container,
    pathSteps,
}));

declare export class ExprIdContainer {
    type: 'exprIdContainer';
    exprId: number;
    withExprId(exprId: number): ExprIdContainer;
    updateExprId(updater: Updater<number>): ExprIdContainer;
    match<T>(visitor: ExprContainerVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newExprIdContainer = (exprId: number): ExprIdContainer => (new ExprIdContainer({
    type: 'exprIdContainer',
    exprId,
}));

declare export class DefinitionContainer {
    type: 'definitionContainer';
    defName: string;
    withDefName(defName: string): DefinitionContainer;
    updateDefName(updater: Updater<string>): DefinitionContainer;
    match<T>(visitor: ExprContainerVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDefinitionContainer = (defName: string): DefinitionContainer => (new DefinitionContainer({
    type: 'definitionContainer',
    defName,
}));

export type ExprContainer = ExprIdContainer | DefinitionContainer;

export type ExprContainerVisitor<T> = {
    exprIdContainer(exprIdContainer: ExprIdContainer): T,
    definitionContainer(definitionContainer: DefinitionContainer): T,
}

declare export class PickUpExpression {
    type: 'pickUpExpression';
    exprId: number;
    offset: PointDifference;
    screenRect: ScreenRect;
    withExprId(exprId: number): PickUpExpression;
    withOffset(offset: PointDifference): PickUpExpression;
    withScreenRect(screenRect: ScreenRect): PickUpExpression;
    updateExprId(updater: Updater<number>): PickUpExpression;
    updateOffset(updater: Updater<PointDifference>): PickUpExpression;
    updateScreenRect(updater: Updater<ScreenRect>): PickUpExpression;
    match<T>(visitor: DragResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newPickUpExpression = (exprId: number, offset: PointDifference, screenRect: ScreenRect): PickUpExpression => (new PickUpExpression({
    type: 'pickUpExpression',
    exprId,
    offset,
    screenRect,
}));

declare export class DecomposeExpression {
    type: 'decomposeExpression';
    exprPath: ExprPath;
    offset: PointDifference;
    screenRect: ScreenRect;
    withExprPath(exprPath: ExprPath): DecomposeExpression;
    withOffset(offset: PointDifference): DecomposeExpression;
    withScreenRect(screenRect: ScreenRect): DecomposeExpression;
    updateExprPath(updater: Updater<ExprPath>): DecomposeExpression;
    updateOffset(updater: Updater<PointDifference>): DecomposeExpression;
    updateScreenRect(updater: Updater<ScreenRect>): DecomposeExpression;
    match<T>(visitor: DragResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDecomposeExpression = (exprPath: ExprPath, offset: PointDifference, screenRect: ScreenRect): DecomposeExpression => (new DecomposeExpression({
    type: 'decomposeExpression',
    exprPath,
    offset,
    screenRect,
}));

declare export class CreateExpression {
    type: 'createExpression';
    expr: UserExpression;
    offset: PointDifference;
    screenRect: ScreenRect;
    withExpr(expr: UserExpression): CreateExpression;
    withOffset(offset: PointDifference): CreateExpression;
    withScreenRect(screenRect: ScreenRect): CreateExpression;
    updateExpr(updater: Updater<UserExpression>): CreateExpression;
    updateOffset(updater: Updater<PointDifference>): CreateExpression;
    updateScreenRect(updater: Updater<ScreenRect>): CreateExpression;
    match<T>(visitor: DragResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newCreateExpression = (expr: UserExpression, offset: PointDifference, screenRect: ScreenRect): CreateExpression => (new CreateExpression({
    type: 'createExpression',
    expr,
    offset,
    screenRect,
}));

declare export class StartPan {
    type: 'startPan';
    startPos: ScreenPoint;
    withStartPos(startPos: ScreenPoint): StartPan;
    updateStartPos(updater: Updater<ScreenPoint>): StartPan;
    match<T>(visitor: DragResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newStartPan = (startPos: ScreenPoint): StartPan => (new StartPan({
    type: 'startPan',
    startPos,
}));

export type DragResult = PickUpExpression | DecomposeExpression | CreateExpression | StartPan;

export type DragResultVisitor<T> = {
    pickUpExpression(pickUpExpression: PickUpExpression): T,
    decomposeExpression(decomposeExpression: DecomposeExpression): T,
    createExpression(createExpression: CreateExpression): T,
    startPan(startPan: StartPan): T,
}

declare export class DragData {
    userExpr: UserExpression;
    grabOffset: PointDifference;
    screenRect: ScreenRect;
    withUserExpr(userExpr: UserExpression): DragData;
    withGrabOffset(grabOffset: PointDifference): DragData;
    withScreenRect(screenRect: ScreenRect): DragData;
    updateUserExpr(updater: Updater<UserExpression>): DragData;
    updateGrabOffset(updater: Updater<PointDifference>): DragData;
    updateScreenRect(updater: Updater<ScreenRect>): DragData;
    toJS(): any;
    serialize(): any;
};

export const newDragData = (userExpr: UserExpression, grabOffset: PointDifference, screenRect: ScreenRect): DragData => (new DragData({
    userExpr,
    grabOffset,
    screenRect,
}));

declare export class AddToTopLevelResult {
    type: 'addToTopLevelResult';
    expr: UserExpression;
    screenPos: ScreenPoint;
    withExpr(expr: UserExpression): AddToTopLevelResult;
    withScreenPos(screenPos: ScreenPoint): AddToTopLevelResult;
    updateExpr(updater: Updater<UserExpression>): AddToTopLevelResult;
    updateScreenPos(updater: Updater<ScreenPoint>): AddToTopLevelResult;
    match<T>(visitor: DropResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newAddToTopLevelResult = (expr: UserExpression, screenPos: ScreenPoint): AddToTopLevelResult => (new AddToTopLevelResult({
    type: 'addToTopLevelResult',
    expr,
    screenPos,
}));

declare export class InsertAsBodyResult {
    type: 'insertAsBodyResult';
    lambdaPath: ExprPath;
    expr: UserExpression;
    withLambdaPath(lambdaPath: ExprPath): InsertAsBodyResult;
    withExpr(expr: UserExpression): InsertAsBodyResult;
    updateLambdaPath(updater: Updater<ExprPath>): InsertAsBodyResult;
    updateExpr(updater: Updater<UserExpression>): InsertAsBodyResult;
    match<T>(visitor: DropResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newInsertAsBodyResult = (lambdaPath: ExprPath, expr: UserExpression): InsertAsBodyResult => (new InsertAsBodyResult({
    type: 'insertAsBodyResult',
    lambdaPath,
    expr,
}));

declare export class InsertAsArgResult {
    type: 'insertAsArgResult';
    path: ExprPath;
    expr: UserExpression;
    withPath(path: ExprPath): InsertAsArgResult;
    withExpr(expr: UserExpression): InsertAsArgResult;
    updatePath(updater: Updater<ExprPath>): InsertAsArgResult;
    updateExpr(updater: Updater<UserExpression>): InsertAsArgResult;
    match<T>(visitor: DropResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newInsertAsArgResult = (path: ExprPath, expr: UserExpression): InsertAsArgResult => (new InsertAsArgResult({
    type: 'insertAsArgResult',
    path,
    expr,
}));

declare export class RemoveResult {
    type: 'removeResult';
    match<T>(visitor: DropResultVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newRemoveResult = (): RemoveResult => (new RemoveResult({
    type: 'removeResult',
}));

export type DropResult = AddToTopLevelResult | InsertAsBodyResult | InsertAsArgResult | RemoveResult;

export type DropResultVisitor<T> = {
    addToTopLevelResult(addToTopLevelResult: AddToTopLevelResult): T,
    insertAsBodyResult(insertAsBodyResult: InsertAsBodyResult): T,
    insertAsArgResult(insertAsArgResult: InsertAsArgResult): T,
    removeResult(removeResult: RemoveResult): T,
}

declare export class ExpressionKey {
    type: 'expressionKey';
    exprPath: ExprPath;
    withExprPath(exprPath: ExprPath): ExpressionKey;
    updateExprPath(updater: Updater<ExprPath>): ExpressionKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newExpressionKey = (exprPath: ExprPath): ExpressionKey => (new ExpressionKey({
    type: 'expressionKey',
    exprPath,
}));

declare export class EmptyBodyKey {
    type: 'emptyBodyKey';
    lambdaPath: ExprPath;
    withLambdaPath(lambdaPath: ExprPath): EmptyBodyKey;
    updateLambdaPath(updater: Updater<ExprPath>): EmptyBodyKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newEmptyBodyKey = (lambdaPath: ExprPath): EmptyBodyKey => (new EmptyBodyKey({
    type: 'emptyBodyKey',
    lambdaPath,
}));

declare export class LambdaVarKey {
    type: 'lambdaVarKey';
    lambdaPath: ExprPath;
    withLambdaPath(lambdaPath: ExprPath): LambdaVarKey;
    updateLambdaPath(updater: Updater<ExprPath>): LambdaVarKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newLambdaVarKey = (lambdaPath: ExprPath): LambdaVarKey => (new LambdaVarKey({
    type: 'lambdaVarKey',
    lambdaPath,
}));

declare export class DefinitionKey {
    type: 'definitionKey';
    defName: string;
    withDefName(defName: string): DefinitionKey;
    updateDefName(updater: Updater<string>): DefinitionKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    toJS(): any;
    serialize(): any;
};

export const newDefinitionKey = (defName: string): DefinitionKey => (new DefinitionKey({
    type: 'definitionKey',
    defName,
}));

export type ViewKey = ExpressionKey | EmptyBodyKey | LambdaVarKey | DefinitionKey;

export type ViewKeyVisitor<T> = {
    expressionKey(expressionKey: ExpressionKey): T,
    emptyBodyKey(emptyBodyKey: EmptyBodyKey): T,
    lambdaVarKey(lambdaVarKey: LambdaVarKey): T,
    definitionKey(definitionKey: DefinitionKey): T,
}

