/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 *
 * @flow
 */
 
import {IList, IMap, ISet, ListLens, MapLens} from './types-collections';
import {Lens} from './types-lib';
import type {Updater} from './types-lib';

import {
    ScreenPointMixin,
    ScreenRectMixin,
} from './types-mixins';

declare export class State {
    static make(canvasExpressions: IMap<number, CanvasExpression>, nextExprId: number, canvasDefinitions: IMap<string, CanvasPoint>, definitions: IMap<string, ?UserExpression>, pendingResults: IMap<number, PendingResult>, activeDrags: IMap<number, DragData>, highlightedExprs: ISet<ExprPath>, highlightedEmptyBodies: ISet<ExprPath>, highlightedDefinitionBodies: ISet<string>, paletteState: 'none' | 'lambda' | 'definition'): State;
    canvasExpressions: IMap<number, CanvasExpression>;
    nextExprId: number;
    canvasDefinitions: IMap<string, CanvasPoint>;
    definitions: IMap<string, ?UserExpression>;
    pendingResults: IMap<number, PendingResult>;
    activeDrags: IMap<number, DragData>;
    highlightedExprs: ISet<ExprPath>;
    highlightedEmptyBodies: ISet<ExprPath>;
    highlightedDefinitionBodies: ISet<string>;
    paletteState: 'none' | 'lambda' | 'definition';
    withCanvasExpressions(canvasExpressions: IMap<number, CanvasExpression>): State;
    withNextExprId(nextExprId: number): State;
    withCanvasDefinitions(canvasDefinitions: IMap<string, CanvasPoint>): State;
    withDefinitions(definitions: IMap<string, ?UserExpression>): State;
    withPendingResults(pendingResults: IMap<number, PendingResult>): State;
    withActiveDrags(activeDrags: IMap<number, DragData>): State;
    withHighlightedExprs(highlightedExprs: ISet<ExprPath>): State;
    withHighlightedEmptyBodies(highlightedEmptyBodies: ISet<ExprPath>): State;
    withHighlightedDefinitionBodies(highlightedDefinitionBodies: ISet<string>): State;
    withPaletteState(paletteState: 'none' | 'lambda' | 'definition'): State;
    updateCanvasExpressions(updater: Updater<IMap<number, CanvasExpression>>): State;
    updateNextExprId(updater: Updater<number>): State;
    updateCanvasDefinitions(updater: Updater<IMap<string, CanvasPoint>>): State;
    updateDefinitions(updater: Updater<IMap<string, ?UserExpression>>): State;
    updatePendingResults(updater: Updater<IMap<number, PendingResult>>): State;
    updateActiveDrags(updater: Updater<IMap<number, DragData>>): State;
    updateHighlightedExprs(updater: Updater<ISet<ExprPath>>): State;
    updateHighlightedEmptyBodies(updater: Updater<ISet<ExprPath>>): State;
    updateHighlightedDefinitionBodies(updater: Updater<ISet<string>>): State;
    updatePaletteState(updater: Updater<'none' | 'lambda' | 'definition'>): State;
    lens(): StateLens<State>;
    serialize(): any;
}

declare export class StateLens<Result> extends Lens<State, Result> {
    canvasExpressions(): CanvasExpressionMapLens<number, Result>;
    nextExprId(): Lens<number, Result>;
    canvasDefinitions(): CanvasPointMapLens<string, Result>;
    definitions(): MapLens<string, ?UserExpression, Result>;
    pendingResults(): PendingResultMapLens<number, Result>;
    activeDrags(): DragDataMapLens<number, Result>;
    highlightedExprs(): Lens<ISet<ExprPath>, Result>;
    highlightedEmptyBodies(): Lens<ISet<ExprPath>, Result>;
    highlightedDefinitionBodies(): Lens<ISet<string>, Result>;
    paletteState(): Lens<'none' | 'lambda' | 'definition', Result>;
}

declare export class Reset {
    static make(): Reset;
    type: 'reset';
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class ToggleLambdaPalette {
    static make(): ToggleLambdaPalette;
    type: 'toggleLambdaPalette';
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class ToggleDefinitionPalette {
    static make(): ToggleDefinitionPalette;
    type: 'toggleDefinitionPalette';
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class AddExpression {
    static make(canvasExpr: CanvasExpression): AddExpression;
    type: 'addExpression';
    canvasExpr: CanvasExpression;
    withCanvasExpr(canvasExpr: CanvasExpression): AddExpression;
    updateCanvasExpr(updater: Updater<CanvasExpression>): AddExpression;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class PlaceDefinition {
    static make(defName: string, screenPos: ScreenPoint): PlaceDefinition;
    type: 'placeDefinition';
    defName: string;
    screenPos: ScreenPoint;
    withDefName(defName: string): PlaceDefinition;
    withScreenPos(screenPos: ScreenPoint): PlaceDefinition;
    updateDefName(updater: Updater<string>): PlaceDefinition;
    updateScreenPos(updater: Updater<ScreenPoint>): PlaceDefinition;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class DeleteDefinition {
    static make(defName: string): DeleteDefinition;
    type: 'deleteDefinition';
    defName: string;
    withDefName(defName: string): DeleteDefinition;
    updateDefName(updater: Updater<string>): DeleteDefinition;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class MoveExpression {
    static make(exprId: number, pos: CanvasPoint): MoveExpression;
    type: 'moveExpression';
    exprId: number;
    pos: CanvasPoint;
    withExprId(exprId: number): MoveExpression;
    withPos(pos: CanvasPoint): MoveExpression;
    updateExprId(updater: Updater<number>): MoveExpression;
    updatePos(updater: Updater<CanvasPoint>): MoveExpression;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class DecomposeExpressionAction {
    static make(path: ExprPath, targetPos: CanvasPoint): DecomposeExpressionAction;
    type: 'decomposeExpressionAction';
    path: ExprPath;
    targetPos: CanvasPoint;
    withPath(path: ExprPath): DecomposeExpressionAction;
    withTargetPos(targetPos: CanvasPoint): DecomposeExpressionAction;
    updatePath(updater: Updater<ExprPath>): DecomposeExpressionAction;
    updateTargetPos(updater: Updater<CanvasPoint>): DecomposeExpressionAction;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class InsertAsArg {
    static make(argExprId: number, path: ExprPath): InsertAsArg;
    type: 'insertAsArg';
    argExprId: number;
    path: ExprPath;
    withArgExprId(argExprId: number): InsertAsArg;
    withPath(path: ExprPath): InsertAsArg;
    updateArgExprId(updater: Updater<number>): InsertAsArg;
    updatePath(updater: Updater<ExprPath>): InsertAsArg;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class InsertAsBody {
    static make(bodyExprId: number, path: ExprPath): InsertAsBody;
    type: 'insertAsBody';
    bodyExprId: number;
    path: ExprPath;
    withBodyExprId(bodyExprId: number): InsertAsBody;
    withPath(path: ExprPath): InsertAsBody;
    updateBodyExprId(updater: Updater<number>): InsertAsBody;
    updatePath(updater: Updater<ExprPath>): InsertAsBody;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class EvaluateExpression {
    static make(exprId: number): EvaluateExpression;
    type: 'evaluateExpression';
    exprId: number;
    withExprId(exprId: number): EvaluateExpression;
    updateExprId(updater: Updater<number>): EvaluateExpression;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class PlacePendingResult {
    static make(exprId: number, width: number, height: number): PlacePendingResult;
    type: 'placePendingResult';
    exprId: number;
    width: number;
    height: number;
    withExprId(exprId: number): PlacePendingResult;
    withWidth(width: number): PlacePendingResult;
    withHeight(height: number): PlacePendingResult;
    updateExprId(updater: Updater<number>): PlacePendingResult;
    updateWidth(updater: Updater<number>): PlacePendingResult;
    updateHeight(updater: Updater<number>): PlacePendingResult;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class FingerDown {
    static make(fingerId: number, screenPos: ScreenPoint): FingerDown;
    type: 'fingerDown';
    fingerId: number;
    screenPos: ScreenPoint;
    withFingerId(fingerId: number): FingerDown;
    withScreenPos(screenPos: ScreenPoint): FingerDown;
    updateFingerId(updater: Updater<number>): FingerDown;
    updateScreenPos(updater: Updater<ScreenPoint>): FingerDown;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class FingerMove {
    static make(fingerId: number, screenPos: ScreenPoint): FingerMove;
    type: 'fingerMove';
    fingerId: number;
    screenPos: ScreenPoint;
    withFingerId(fingerId: number): FingerMove;
    withScreenPos(screenPos: ScreenPoint): FingerMove;
    updateFingerId(updater: Updater<number>): FingerMove;
    updateScreenPos(updater: Updater<ScreenPoint>): FingerMove;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

declare export class FingerUp {
    static make(fingerId: number, screenPos: ScreenPoint): FingerUp;
    type: 'fingerUp';
    fingerId: number;
    screenPos: ScreenPoint;
    withFingerId(fingerId: number): FingerUp;
    withScreenPos(screenPos: ScreenPoint): FingerUp;
    updateFingerId(updater: Updater<number>): FingerUp;
    updateScreenPos(updater: Updater<ScreenPoint>): FingerUp;
    match<T>(visitor: ActionVisitor<T>): T;
    serialize(): any;
}

export type Action = Reset | ToggleLambdaPalette | ToggleDefinitionPalette | AddExpression | PlaceDefinition | DeleteDefinition | MoveExpression | DecomposeExpressionAction | InsertAsArg | InsertAsBody | EvaluateExpression | PlacePendingResult | FingerDown | FingerMove | FingerUp;

export type ActionVisitor<T> = {
    reset(reset: Reset): T,
    toggleLambdaPalette(toggleLambdaPalette: ToggleLambdaPalette): T,
    toggleDefinitionPalette(toggleDefinitionPalette: ToggleDefinitionPalette): T,
    addExpression(addExpression: AddExpression): T,
    placeDefinition(placeDefinition: PlaceDefinition): T,
    deleteDefinition(deleteDefinition: DeleteDefinition): T,
    moveExpression(moveExpression: MoveExpression): T,
    decomposeExpressionAction(decomposeExpressionAction: DecomposeExpressionAction): T,
    insertAsArg(insertAsArg: InsertAsArg): T,
    insertAsBody(insertAsBody: InsertAsBody): T,
    evaluateExpression(evaluateExpression: EvaluateExpression): T,
    placePendingResult(placePendingResult: PlacePendingResult): T,
    fingerDown(fingerDown: FingerDown): T,
    fingerMove(fingerMove: FingerMove): T,
    fingerUp(fingerUp: FingerUp): T,
}

declare export class Lambda {
    static make(varName: string, body: Expression): Lambda;
    type: 'lambda';
    varName: string;
    body: Expression;
    withVarName(varName: string): Lambda;
    withBody(body: Expression): Lambda;
    updateVarName(updater: Updater<string>): Lambda;
    updateBody(updater: Updater<Expression>): Lambda;
    match<T>(visitor: ExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class FuncCall {
    static make(func: Expression, arg: Expression): FuncCall;
    type: 'funcCall';
    func: Expression;
    arg: Expression;
    withFunc(func: Expression): FuncCall;
    withArg(arg: Expression): FuncCall;
    updateFunc(updater: Updater<Expression>): FuncCall;
    updateArg(updater: Updater<Expression>): FuncCall;
    match<T>(visitor: ExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class Variable {
    static make(varName: string): Variable;
    type: 'variable';
    varName: string;
    withVarName(varName: string): Variable;
    updateVarName(updater: Updater<string>): Variable;
    match<T>(visitor: ExpressionVisitor<T>): T;
    serialize(): any;
}

export type Expression = Lambda | FuncCall | Variable;

export type ExpressionVisitor<T> = {
    lambda(lambda: Lambda): T,
    funcCall(funcCall: FuncCall): T,
    variable(variable: Variable): T,
}

export type Slot = {
    isValue: boolean,
    expr: EvalExpression,
    originalVarName: string
};

export type VarMarker = number;

declare export class EvalLambda {
    static make(varMarker: VarMarker, originalVarName: string, body: EvalExpression): EvalLambda;
    type: 'evalLambda';
    varMarker: VarMarker;
    originalVarName: string;
    body: EvalExpression;
    withVarMarker(varMarker: VarMarker): EvalLambda;
    withOriginalVarName(originalVarName: string): EvalLambda;
    withBody(body: EvalExpression): EvalLambda;
    updateVarMarker(updater: Updater<VarMarker>): EvalLambda;
    updateOriginalVarName(updater: Updater<string>): EvalLambda;
    updateBody(updater: Updater<EvalExpression>): EvalLambda;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class EvalFuncCall {
    static make(func: EvalExpression, arg: EvalExpression): EvalFuncCall;
    type: 'evalFuncCall';
    func: EvalExpression;
    arg: EvalExpression;
    withFunc(func: EvalExpression): EvalFuncCall;
    withArg(arg: EvalExpression): EvalFuncCall;
    updateFunc(updater: Updater<EvalExpression>): EvalFuncCall;
    updateArg(updater: Updater<EvalExpression>): EvalFuncCall;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class EvalBoundVariable {
    static make(slot: Slot): EvalBoundVariable;
    type: 'evalBoundVariable';
    slot: Slot;
    withSlot(slot: Slot): EvalBoundVariable;
    updateSlot(updater: Updater<Slot>): EvalBoundVariable;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class EvalUnboundVariable {
    static make(varMarker: VarMarker, originalVarName: string): EvalUnboundVariable;
    type: 'evalUnboundVariable';
    varMarker: VarMarker;
    originalVarName: string;
    withVarMarker(varMarker: VarMarker): EvalUnboundVariable;
    withOriginalVarName(originalVarName: string): EvalUnboundVariable;
    updateVarMarker(updater: Updater<VarMarker>): EvalUnboundVariable;
    updateOriginalVarName(updater: Updater<string>): EvalUnboundVariable;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class EvalFreeVariable {
    static make(varName: string): EvalFreeVariable;
    type: 'evalFreeVariable';
    varName: string;
    withVarName(varName: string): EvalFreeVariable;
    updateVarName(updater: Updater<string>): EvalFreeVariable;
    match<T>(visitor: EvalExpressionVisitor<T>): T;
    serialize(): any;
}

export type EvalExpression = EvalLambda | EvalFuncCall | EvalBoundVariable | EvalUnboundVariable | EvalFreeVariable;

export type EvalExpressionVisitor<T> = {
    evalLambda(evalLambda: EvalLambda): T,
    evalFuncCall(evalFuncCall: EvalFuncCall): T,
    evalBoundVariable(evalBoundVariable: EvalBoundVariable): T,
    evalUnboundVariable(evalUnboundVariable: EvalUnboundVariable): T,
    evalFreeVariable(evalFreeVariable: EvalFreeVariable): T,
}

declare export class UserLambda {
    static make(varName: string, body: ?UserExpression): UserLambda;
    type: 'userLambda';
    varName: string;
    body: ?UserExpression;
    withVarName(varName: string): UserLambda;
    withBody(body: ?UserExpression): UserLambda;
    updateVarName(updater: Updater<string>): UserLambda;
    updateBody(updater: Updater<?UserExpression>): UserLambda;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class UserFuncCall {
    static make(func: UserExpression, arg: UserExpression): UserFuncCall;
    type: 'userFuncCall';
    func: UserExpression;
    arg: UserExpression;
    withFunc(func: UserExpression): UserFuncCall;
    withArg(arg: UserExpression): UserFuncCall;
    updateFunc(updater: Updater<UserExpression>): UserFuncCall;
    updateArg(updater: Updater<UserExpression>): UserFuncCall;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class UserVariable {
    static make(varName: string): UserVariable;
    type: 'userVariable';
    varName: string;
    withVarName(varName: string): UserVariable;
    updateVarName(updater: Updater<string>): UserVariable;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class UserReference {
    static make(defName: string): UserReference;
    type: 'userReference';
    defName: string;
    withDefName(defName: string): UserReference;
    updateDefName(updater: Updater<string>): UserReference;
    match<T>(visitor: UserExpressionVisitor<T>): T;
    serialize(): any;
}

export type UserExpression = UserLambda | UserFuncCall | UserVariable | UserReference;

export type UserExpressionVisitor<T> = {
    userLambda(userLambda: UserLambda): T,
    userFuncCall(userFuncCall: UserFuncCall): T,
    userVariable(userVariable: UserVariable): T,
    userReference(userReference: UserReference): T,
}

declare export class CanvasExpression {
    static make(expr: UserExpression, pos: CanvasPoint): CanvasExpression;
    expr: UserExpression;
    pos: CanvasPoint;
    withExpr(expr: UserExpression): CanvasExpression;
    withPos(pos: CanvasPoint): CanvasExpression;
    updateExpr(updater: Updater<UserExpression>): CanvasExpression;
    updatePos(updater: Updater<CanvasPoint>): CanvasExpression;
    lens(): CanvasExpressionLens<CanvasExpression>;
    serialize(): any;
}

declare export class CanvasExpressionLens<Result> extends Lens<CanvasExpression, Result> {
    expr(): Lens<UserExpression, Result>;
    pos(): CanvasPointLens<Result>;
}

declare export class PendingResult {
    static make(expr: UserExpression, sourceExprId: number): PendingResult;
    expr: UserExpression;
    sourceExprId: number;
    withExpr(expr: UserExpression): PendingResult;
    withSourceExprId(sourceExprId: number): PendingResult;
    updateExpr(updater: Updater<UserExpression>): PendingResult;
    updateSourceExprId(updater: Updater<number>): PendingResult;
    lens(): PendingResultLens<PendingResult>;
    serialize(): any;
}

declare export class PendingResultLens<Result> extends Lens<PendingResult, Result> {
    expr(): Lens<UserExpression, Result>;
    sourceExprId(): Lens<number, Result>;
}

declare export class DisplayState {
    static make(screenExpressions: IList<ScreenExpression>, screenDefinitions: IList<ScreenDefinition>, paletteState: PaletteDisplayState, measureRequests: IList<MeasureRequest>, definitionNames: IList<string>): DisplayState;
    screenExpressions: IList<ScreenExpression>;
    screenDefinitions: IList<ScreenDefinition>;
    paletteState: PaletteDisplayState;
    measureRequests: IList<MeasureRequest>;
    definitionNames: IList<string>;
    withScreenExpressions(screenExpressions: IList<ScreenExpression>): DisplayState;
    withScreenDefinitions(screenDefinitions: IList<ScreenDefinition>): DisplayState;
    withPaletteState(paletteState: PaletteDisplayState): DisplayState;
    withMeasureRequests(measureRequests: IList<MeasureRequest>): DisplayState;
    withDefinitionNames(definitionNames: IList<string>): DisplayState;
    updateScreenExpressions(updater: Updater<IList<ScreenExpression>>): DisplayState;
    updateScreenDefinitions(updater: Updater<IList<ScreenDefinition>>): DisplayState;
    updatePaletteState(updater: Updater<PaletteDisplayState>): DisplayState;
    updateMeasureRequests(updater: Updater<IList<MeasureRequest>>): DisplayState;
    updateDefinitionNames(updater: Updater<IList<string>>): DisplayState;
    lens(): DisplayStateLens<DisplayState>;
    serialize(): any;
}

declare export class DisplayStateLens<Result> extends Lens<DisplayState, Result> {
    screenExpressions(): ScreenExpressionListLens<Result>;
    screenDefinitions(): ScreenDefinitionListLens<Result>;
    paletteState(): PaletteDisplayStateLens<Result>;
    measureRequests(): MeasureRequestListLens<Result>;
    definitionNames(): ListLens<string, Result>;
}

declare export class PaletteDisplayState {
    static make(activePalette: 'none' | 'lambda' | 'definition', lambdas: IList<string>, definitions: IList<string>): PaletteDisplayState;
    activePalette: 'none' | 'lambda' | 'definition';
    lambdas: IList<string>;
    definitions: IList<string>;
    withActivePalette(activePalette: 'none' | 'lambda' | 'definition'): PaletteDisplayState;
    withLambdas(lambdas: IList<string>): PaletteDisplayState;
    withDefinitions(definitions: IList<string>): PaletteDisplayState;
    updateActivePalette(updater: Updater<'none' | 'lambda' | 'definition'>): PaletteDisplayState;
    updateLambdas(updater: Updater<IList<string>>): PaletteDisplayState;
    updateDefinitions(updater: Updater<IList<string>>): PaletteDisplayState;
    lens(): PaletteDisplayStateLens<PaletteDisplayState>;
    serialize(): any;
}

declare export class PaletteDisplayStateLens<Result> extends Lens<PaletteDisplayState, Result> {
    activePalette(): Lens<'none' | 'lambda' | 'definition', Result>;
    lambdas(): ListLens<string, Result>;
    definitions(): ListLens<string, Result>;
}

declare export class MeasureRequest {
    static make(expr: DisplayExpression, resultHandler: (width: number, height: number) => void): MeasureRequest;
    expr: DisplayExpression;
    resultHandler: (width: number, height: number) => void;
    withExpr(expr: DisplayExpression): MeasureRequest;
    withResultHandler(resultHandler: (width: number, height: number) => void): MeasureRequest;
    updateExpr(updater: Updater<DisplayExpression>): MeasureRequest;
    updateResultHandler(updater: Updater<(width: number, height: number) => void>): MeasureRequest;
    lens(): MeasureRequestLens<MeasureRequest>;
    serialize(): any;
}

declare export class MeasureRequestLens<Result> extends Lens<MeasureRequest, Result> {
    expr(): Lens<DisplayExpression, Result>;
    resultHandler(): Lens<(width: number, height: number) => void, Result>;
}

declare export class ScreenDefinition {
    static make(defName: string, expr: ?DisplayExpression, pos: ScreenPoint, defKey: ?DefinitionKey, refKey: ?DefinitionRefKey, emptyBodyKey: ?DefinitionEmptyBodyKey, shouldHighlightEmptyBody: boolean, key: string, isDragging: boolean): ScreenDefinition;
    defName: string;
    expr: ?DisplayExpression;
    pos: ScreenPoint;
    defKey: ?DefinitionKey;
    refKey: ?DefinitionRefKey;
    emptyBodyKey: ?DefinitionEmptyBodyKey;
    shouldHighlightEmptyBody: boolean;
    key: string;
    isDragging: boolean;
    withDefName(defName: string): ScreenDefinition;
    withExpr(expr: ?DisplayExpression): ScreenDefinition;
    withPos(pos: ScreenPoint): ScreenDefinition;
    withDefKey(defKey: ?DefinitionKey): ScreenDefinition;
    withRefKey(refKey: ?DefinitionRefKey): ScreenDefinition;
    withEmptyBodyKey(emptyBodyKey: ?DefinitionEmptyBodyKey): ScreenDefinition;
    withShouldHighlightEmptyBody(shouldHighlightEmptyBody: boolean): ScreenDefinition;
    withKey(key: string): ScreenDefinition;
    withIsDragging(isDragging: boolean): ScreenDefinition;
    updateDefName(updater: Updater<string>): ScreenDefinition;
    updateExpr(updater: Updater<?DisplayExpression>): ScreenDefinition;
    updatePos(updater: Updater<ScreenPoint>): ScreenDefinition;
    updateDefKey(updater: Updater<?DefinitionKey>): ScreenDefinition;
    updateRefKey(updater: Updater<?DefinitionRefKey>): ScreenDefinition;
    updateEmptyBodyKey(updater: Updater<?DefinitionEmptyBodyKey>): ScreenDefinition;
    updateShouldHighlightEmptyBody(updater: Updater<boolean>): ScreenDefinition;
    updateKey(updater: Updater<string>): ScreenDefinition;
    updateIsDragging(updater: Updater<boolean>): ScreenDefinition;
    lens(): ScreenDefinitionLens<ScreenDefinition>;
    serialize(): any;
}

declare export class ScreenDefinitionLens<Result> extends Lens<ScreenDefinition, Result> {
    defName(): Lens<string, Result>;
    expr(): Lens<?DisplayExpression, Result>;
    pos(): ScreenPointLens<Result>;
    defKey(): Lens<?DefinitionKey, Result>;
    refKey(): Lens<?DefinitionRefKey, Result>;
    emptyBodyKey(): Lens<?DefinitionEmptyBodyKey, Result>;
    shouldHighlightEmptyBody(): Lens<boolean, Result>;
    key(): Lens<string, Result>;
    isDragging(): Lens<boolean, Result>;
}

declare export class ScreenExpression {
    static make(expr: DisplayExpression, pos: ScreenPoint, key: string, isDragging: boolean, executeHandler: ?() => void): ScreenExpression;
    expr: DisplayExpression;
    pos: ScreenPoint;
    key: string;
    isDragging: boolean;
    executeHandler: ?() => void;
    withExpr(expr: DisplayExpression): ScreenExpression;
    withPos(pos: ScreenPoint): ScreenExpression;
    withKey(key: string): ScreenExpression;
    withIsDragging(isDragging: boolean): ScreenExpression;
    withExecuteHandler(executeHandler: ?() => void): ScreenExpression;
    updateExpr(updater: Updater<DisplayExpression>): ScreenExpression;
    updatePos(updater: Updater<ScreenPoint>): ScreenExpression;
    updateKey(updater: Updater<string>): ScreenExpression;
    updateIsDragging(updater: Updater<boolean>): ScreenExpression;
    updateExecuteHandler(updater: Updater<?() => void>): ScreenExpression;
    lens(): ScreenExpressionLens<ScreenExpression>;
    serialize(): any;
}

declare export class ScreenExpressionLens<Result> extends Lens<ScreenExpression, Result> {
    expr(): Lens<DisplayExpression, Result>;
    pos(): ScreenPointLens<Result>;
    key(): Lens<string, Result>;
    isDragging(): Lens<boolean, Result>;
    executeHandler(): Lens<?() => void, Result>;
}

declare export class DisplayLambda {
    static make(exprKey: ?ViewKey, shouldHighlight: boolean, varKey: ?LambdaVarKey, emptyBodyKey: ?EmptyBodyKey, shouldHighlightEmptyBody: boolean, varName: string, body: ?DisplayExpression): DisplayLambda;
    type: 'displayLambda';
    exprKey: ?ViewKey;
    shouldHighlight: boolean;
    varKey: ?LambdaVarKey;
    emptyBodyKey: ?EmptyBodyKey;
    shouldHighlightEmptyBody: boolean;
    varName: string;
    body: ?DisplayExpression;
    withExprKey(exprKey: ?ViewKey): DisplayLambda;
    withShouldHighlight(shouldHighlight: boolean): DisplayLambda;
    withVarKey(varKey: ?LambdaVarKey): DisplayLambda;
    withEmptyBodyKey(emptyBodyKey: ?EmptyBodyKey): DisplayLambda;
    withShouldHighlightEmptyBody(shouldHighlightEmptyBody: boolean): DisplayLambda;
    withVarName(varName: string): DisplayLambda;
    withBody(body: ?DisplayExpression): DisplayLambda;
    updateExprKey(updater: Updater<?ViewKey>): DisplayLambda;
    updateShouldHighlight(updater: Updater<boolean>): DisplayLambda;
    updateVarKey(updater: Updater<?LambdaVarKey>): DisplayLambda;
    updateEmptyBodyKey(updater: Updater<?EmptyBodyKey>): DisplayLambda;
    updateShouldHighlightEmptyBody(updater: Updater<boolean>): DisplayLambda;
    updateVarName(updater: Updater<string>): DisplayLambda;
    updateBody(updater: Updater<?DisplayExpression>): DisplayLambda;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class DisplayFuncCall {
    static make(exprKey: ?ExpressionKey, shouldHighlight: boolean, func: DisplayExpression, arg: DisplayExpression): DisplayFuncCall;
    type: 'displayFuncCall';
    exprKey: ?ExpressionKey;
    shouldHighlight: boolean;
    func: DisplayExpression;
    arg: DisplayExpression;
    withExprKey(exprKey: ?ExpressionKey): DisplayFuncCall;
    withShouldHighlight(shouldHighlight: boolean): DisplayFuncCall;
    withFunc(func: DisplayExpression): DisplayFuncCall;
    withArg(arg: DisplayExpression): DisplayFuncCall;
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayFuncCall;
    updateShouldHighlight(updater: Updater<boolean>): DisplayFuncCall;
    updateFunc(updater: Updater<DisplayExpression>): DisplayFuncCall;
    updateArg(updater: Updater<DisplayExpression>): DisplayFuncCall;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class DisplayVariable {
    static make(exprKey: ?ExpressionKey, shouldHighlight: boolean, varName: string): DisplayVariable;
    type: 'displayVariable';
    exprKey: ?ExpressionKey;
    shouldHighlight: boolean;
    varName: string;
    withExprKey(exprKey: ?ExpressionKey): DisplayVariable;
    withShouldHighlight(shouldHighlight: boolean): DisplayVariable;
    withVarName(varName: string): DisplayVariable;
    updateExprKey(updater: Updater<?ExpressionKey>): DisplayVariable;
    updateShouldHighlight(updater: Updater<boolean>): DisplayVariable;
    updateVarName(updater: Updater<string>): DisplayVariable;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    serialize(): any;
}

declare export class DisplayReference {
    static make(exprKey: ?ViewKey, shouldHighlight: boolean, shouldShowError: boolean, defName: string): DisplayReference;
    type: 'displayReference';
    exprKey: ?ViewKey;
    shouldHighlight: boolean;
    shouldShowError: boolean;
    defName: string;
    withExprKey(exprKey: ?ViewKey): DisplayReference;
    withShouldHighlight(shouldHighlight: boolean): DisplayReference;
    withShouldShowError(shouldShowError: boolean): DisplayReference;
    withDefName(defName: string): DisplayReference;
    updateExprKey(updater: Updater<?ViewKey>): DisplayReference;
    updateShouldHighlight(updater: Updater<boolean>): DisplayReference;
    updateShouldShowError(updater: Updater<boolean>): DisplayReference;
    updateDefName(updater: Updater<string>): DisplayReference;
    match<T>(visitor: DisplayExpressionVisitor<T>): T;
    serialize(): any;
}

export type DisplayExpression = DisplayLambda | DisplayFuncCall | DisplayVariable | DisplayReference;

export type DisplayExpressionVisitor<T> = {
    displayLambda(displayLambda: DisplayLambda): T,
    displayFuncCall(displayFuncCall: DisplayFuncCall): T,
    displayVariable(displayVariable: DisplayVariable): T,
    displayReference(displayReference: DisplayReference): T,
}

declare export class CanvasPoint {
    static make(canvasX: number, canvasY: number): CanvasPoint;
    canvasX: number;
    canvasY: number;
    withCanvasX(canvasX: number): CanvasPoint;
    withCanvasY(canvasY: number): CanvasPoint;
    updateCanvasX(updater: Updater<number>): CanvasPoint;
    updateCanvasY(updater: Updater<number>): CanvasPoint;
    lens(): CanvasPointLens<CanvasPoint>;
    serialize(): any;
}

declare export class CanvasPointLens<Result> extends Lens<CanvasPoint, Result> {
    canvasX(): Lens<number, Result>;
    canvasY(): Lens<number, Result>;
}

declare export class PointDifference {
    static make(dx: number, dy: number): PointDifference;
    dx: number;
    dy: number;
    withDx(dx: number): PointDifference;
    withDy(dy: number): PointDifference;
    updateDx(updater: Updater<number>): PointDifference;
    updateDy(updater: Updater<number>): PointDifference;
    lens(): PointDifferenceLens<PointDifference>;
    serialize(): any;
}

declare export class PointDifferenceLens<Result> extends Lens<PointDifference, Result> {
    dx(): Lens<number, Result>;
    dy(): Lens<number, Result>;
}

declare export class ScreenPoint extends ScreenPointMixin {
    static make(screenX: number, screenY: number): ScreenPoint;
    screenX: number;
    screenY: number;
    withScreenX(screenX: number): ScreenPoint;
    withScreenY(screenY: number): ScreenPoint;
    updateScreenX(updater: Updater<number>): ScreenPoint;
    updateScreenY(updater: Updater<number>): ScreenPoint;
    lens(): ScreenPointLens<ScreenPoint>;
    serialize(): any;
}

declare export class ScreenPointLens<Result> extends Lens<ScreenPoint, Result> {
    screenX(): Lens<number, Result>;
    screenY(): Lens<number, Result>;
}

declare export class ScreenRect extends ScreenRectMixin {
    static make(topLeft: ScreenPoint, bottomRight: ScreenPoint): ScreenRect;
    topLeft: ScreenPoint;
    bottomRight: ScreenPoint;
    withTopLeft(topLeft: ScreenPoint): ScreenRect;
    withBottomRight(bottomRight: ScreenPoint): ScreenRect;
    updateTopLeft(updater: Updater<ScreenPoint>): ScreenRect;
    updateBottomRight(updater: Updater<ScreenPoint>): ScreenRect;
    lens(): ScreenRectLens<ScreenRect>;
    serialize(): any;
}

declare export class ScreenRectLens<Result> extends Lens<ScreenRect, Result> {
    topLeft(): ScreenPointLens<Result>;
    bottomRight(): ScreenPointLens<Result>;
}

export type PathComponent = 'func' | 'arg' | 'body';

declare export class ExprPath {
    static make(container: ExprContainer, pathSteps: IList<PathComponent>): ExprPath;
    container: ExprContainer;
    pathSteps: IList<PathComponent>;
    withContainer(container: ExprContainer): ExprPath;
    withPathSteps(pathSteps: IList<PathComponent>): ExprPath;
    updateContainer(updater: Updater<ExprContainer>): ExprPath;
    updatePathSteps(updater: Updater<IList<PathComponent>>): ExprPath;
    lens(): ExprPathLens<ExprPath>;
    serialize(): any;
}

declare export class ExprPathLens<Result> extends Lens<ExprPath, Result> {
    container(): Lens<ExprContainer, Result>;
    pathSteps(): ListLens<PathComponent, Result>;
}

declare export class ExprIdContainer {
    static make(exprId: number): ExprIdContainer;
    type: 'exprIdContainer';
    exprId: number;
    withExprId(exprId: number): ExprIdContainer;
    updateExprId(updater: Updater<number>): ExprIdContainer;
    match<T>(visitor: ExprContainerVisitor<T>): T;
    serialize(): any;
}

declare export class DefinitionContainer {
    static make(defName: string): DefinitionContainer;
    type: 'definitionContainer';
    defName: string;
    withDefName(defName: string): DefinitionContainer;
    updateDefName(updater: Updater<string>): DefinitionContainer;
    match<T>(visitor: ExprContainerVisitor<T>): T;
    serialize(): any;
}

export type ExprContainer = ExprIdContainer | DefinitionContainer;

export type ExprContainerVisitor<T> = {
    exprIdContainer(exprIdContainer: ExprIdContainer): T,
    definitionContainer(definitionContainer: DefinitionContainer): T,
}

declare export class PickUpExpression {
    static make(exprId: number, offset: PointDifference, screenRect: ScreenRect): PickUpExpression;
    type: 'pickUpExpression';
    exprId: number;
    offset: PointDifference;
    screenRect: ScreenRect;
    withExprId(exprId: number): PickUpExpression;
    withOffset(offset: PointDifference): PickUpExpression;
    withScreenRect(screenRect: ScreenRect): PickUpExpression;
    updateExprId(updater: Updater<number>): PickUpExpression;
    updateOffset(updater: Updater<PointDifference>): PickUpExpression;
    updateScreenRect(updater: Updater<ScreenRect>): PickUpExpression;
    match<T>(visitor: DragResultVisitor<T>): T;
    serialize(): any;
}

declare export class PickUpDefinition {
    static make(defName: string, offset: PointDifference, screenRect: ScreenRect): PickUpDefinition;
    type: 'pickUpDefinition';
    defName: string;
    offset: PointDifference;
    screenRect: ScreenRect;
    withDefName(defName: string): PickUpDefinition;
    withOffset(offset: PointDifference): PickUpDefinition;
    withScreenRect(screenRect: ScreenRect): PickUpDefinition;
    updateDefName(updater: Updater<string>): PickUpDefinition;
    updateOffset(updater: Updater<PointDifference>): PickUpDefinition;
    updateScreenRect(updater: Updater<ScreenRect>): PickUpDefinition;
    match<T>(visitor: DragResultVisitor<T>): T;
    serialize(): any;
}

declare export class ExtractDefinition {
    static make(defName: string, offset: PointDifference, screenRect: ScreenRect): ExtractDefinition;
    type: 'extractDefinition';
    defName: string;
    offset: PointDifference;
    screenRect: ScreenRect;
    withDefName(defName: string): ExtractDefinition;
    withOffset(offset: PointDifference): ExtractDefinition;
    withScreenRect(screenRect: ScreenRect): ExtractDefinition;
    updateDefName(updater: Updater<string>): ExtractDefinition;
    updateOffset(updater: Updater<PointDifference>): ExtractDefinition;
    updateScreenRect(updater: Updater<ScreenRect>): ExtractDefinition;
    match<T>(visitor: DragResultVisitor<T>): T;
    serialize(): any;
}

declare export class DecomposeExpression {
    static make(exprPath: ExprPath, offset: PointDifference, screenRect: ScreenRect): DecomposeExpression;
    type: 'decomposeExpression';
    exprPath: ExprPath;
    offset: PointDifference;
    screenRect: ScreenRect;
    withExprPath(exprPath: ExprPath): DecomposeExpression;
    withOffset(offset: PointDifference): DecomposeExpression;
    withScreenRect(screenRect: ScreenRect): DecomposeExpression;
    updateExprPath(updater: Updater<ExprPath>): DecomposeExpression;
    updateOffset(updater: Updater<PointDifference>): DecomposeExpression;
    updateScreenRect(updater: Updater<ScreenRect>): DecomposeExpression;
    match<T>(visitor: DragResultVisitor<T>): T;
    serialize(): any;
}

declare export class CreateExpression {
    static make(expr: UserExpression, offset: PointDifference, screenRect: ScreenRect): CreateExpression;
    type: 'createExpression';
    expr: UserExpression;
    offset: PointDifference;
    screenRect: ScreenRect;
    withExpr(expr: UserExpression): CreateExpression;
    withOffset(offset: PointDifference): CreateExpression;
    withScreenRect(screenRect: ScreenRect): CreateExpression;
    updateExpr(updater: Updater<UserExpression>): CreateExpression;
    updateOffset(updater: Updater<PointDifference>): CreateExpression;
    updateScreenRect(updater: Updater<ScreenRect>): CreateExpression;
    match<T>(visitor: DragResultVisitor<T>): T;
    serialize(): any;
}

declare export class StartPan {
    static make(startPos: ScreenPoint): StartPan;
    type: 'startPan';
    startPos: ScreenPoint;
    withStartPos(startPos: ScreenPoint): StartPan;
    updateStartPos(updater: Updater<ScreenPoint>): StartPan;
    match<T>(visitor: DragResultVisitor<T>): T;
    serialize(): any;
}

export type DragResult = PickUpExpression | PickUpDefinition | ExtractDefinition | DecomposeExpression | CreateExpression | StartPan;

export type DragResultVisitor<T> = {
    pickUpExpression(pickUpExpression: PickUpExpression): T,
    pickUpDefinition(pickUpDefinition: PickUpDefinition): T,
    extractDefinition(extractDefinition: ExtractDefinition): T,
    decomposeExpression(decomposeExpression: DecomposeExpression): T,
    createExpression(createExpression: CreateExpression): T,
    startPan(startPan: StartPan): T,
}

declare export class DragData {
    static make(payload: DragPayload, grabOffset: PointDifference, screenRect: ScreenRect): DragData;
    payload: DragPayload;
    grabOffset: PointDifference;
    screenRect: ScreenRect;
    withPayload(payload: DragPayload): DragData;
    withGrabOffset(grabOffset: PointDifference): DragData;
    withScreenRect(screenRect: ScreenRect): DragData;
    updatePayload(updater: Updater<DragPayload>): DragData;
    updateGrabOffset(updater: Updater<PointDifference>): DragData;
    updateScreenRect(updater: Updater<ScreenRect>): DragData;
    lens(): DragDataLens<DragData>;
    serialize(): any;
}

declare export class DragDataLens<Result> extends Lens<DragData, Result> {
    payload(): Lens<DragPayload, Result>;
    grabOffset(): PointDifferenceLens<Result>;
    screenRect(): ScreenRectLens<Result>;
}

declare export class DraggedExpression {
    static make(userExpr: UserExpression): DraggedExpression;
    type: 'draggedExpression';
    userExpr: UserExpression;
    withUserExpr(userExpr: UserExpression): DraggedExpression;
    updateUserExpr(updater: Updater<UserExpression>): DraggedExpression;
    match<T>(visitor: DragPayloadVisitor<T>): T;
    serialize(): any;
}

declare export class DraggedDefinition {
    static make(defName: string): DraggedDefinition;
    type: 'draggedDefinition';
    defName: string;
    withDefName(defName: string): DraggedDefinition;
    updateDefName(updater: Updater<string>): DraggedDefinition;
    match<T>(visitor: DragPayloadVisitor<T>): T;
    serialize(): any;
}

export type DragPayload = DraggedExpression | DraggedDefinition;

export type DragPayloadVisitor<T> = {
    draggedExpression(draggedExpression: DraggedExpression): T,
    draggedDefinition(draggedDefinition: DraggedDefinition): T,
}

declare export class AddToTopLevelResult {
    static make(payload: DragPayload, screenPos: ScreenPoint): AddToTopLevelResult;
    type: 'addToTopLevelResult';
    payload: DragPayload;
    screenPos: ScreenPoint;
    withPayload(payload: DragPayload): AddToTopLevelResult;
    withScreenPos(screenPos: ScreenPoint): AddToTopLevelResult;
    updatePayload(updater: Updater<DragPayload>): AddToTopLevelResult;
    updateScreenPos(updater: Updater<ScreenPoint>): AddToTopLevelResult;
    match<T>(visitor: DropResultVisitor<T>): T;
    serialize(): any;
}

declare export class InsertAsBodyResult {
    static make(lambdaPath: ExprPath, expr: UserExpression): InsertAsBodyResult;
    type: 'insertAsBodyResult';
    lambdaPath: ExprPath;
    expr: UserExpression;
    withLambdaPath(lambdaPath: ExprPath): InsertAsBodyResult;
    withExpr(expr: UserExpression): InsertAsBodyResult;
    updateLambdaPath(updater: Updater<ExprPath>): InsertAsBodyResult;
    updateExpr(updater: Updater<UserExpression>): InsertAsBodyResult;
    match<T>(visitor: DropResultVisitor<T>): T;
    serialize(): any;
}

declare export class InsertAsArgResult {
    static make(path: ExprPath, expr: UserExpression): InsertAsArgResult;
    type: 'insertAsArgResult';
    path: ExprPath;
    expr: UserExpression;
    withPath(path: ExprPath): InsertAsArgResult;
    withExpr(expr: UserExpression): InsertAsArgResult;
    updatePath(updater: Updater<ExprPath>): InsertAsArgResult;
    updateExpr(updater: Updater<UserExpression>): InsertAsArgResult;
    match<T>(visitor: DropResultVisitor<T>): T;
    serialize(): any;
}

declare export class InsertAsDefinitionResult {
    static make(defName: string, expr: UserExpression): InsertAsDefinitionResult;
    type: 'insertAsDefinitionResult';
    defName: string;
    expr: UserExpression;
    withDefName(defName: string): InsertAsDefinitionResult;
    withExpr(expr: UserExpression): InsertAsDefinitionResult;
    updateDefName(updater: Updater<string>): InsertAsDefinitionResult;
    updateExpr(updater: Updater<UserExpression>): InsertAsDefinitionResult;
    match<T>(visitor: DropResultVisitor<T>): T;
    serialize(): any;
}

declare export class RemoveResult {
    static make(): RemoveResult;
    type: 'removeResult';
    match<T>(visitor: DropResultVisitor<T>): T;
    serialize(): any;
}

export type DropResult = AddToTopLevelResult | InsertAsBodyResult | InsertAsArgResult | InsertAsDefinitionResult | RemoveResult;

export type DropResultVisitor<T> = {
    addToTopLevelResult(addToTopLevelResult: AddToTopLevelResult): T,
    insertAsBodyResult(insertAsBodyResult: InsertAsBodyResult): T,
    insertAsArgResult(insertAsArgResult: InsertAsArgResult): T,
    insertAsDefinitionResult(insertAsDefinitionResult: InsertAsDefinitionResult): T,
    removeResult(removeResult: RemoveResult): T,
}

declare export class ExpressionKey {
    static make(exprPath: ExprPath): ExpressionKey;
    type: 'expressionKey';
    exprPath: ExprPath;
    withExprPath(exprPath: ExprPath): ExpressionKey;
    updateExprPath(updater: Updater<ExprPath>): ExpressionKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

declare export class EmptyBodyKey {
    static make(lambdaPath: ExprPath): EmptyBodyKey;
    type: 'emptyBodyKey';
    lambdaPath: ExprPath;
    withLambdaPath(lambdaPath: ExprPath): EmptyBodyKey;
    updateLambdaPath(updater: Updater<ExprPath>): EmptyBodyKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

declare export class LambdaVarKey {
    static make(lambdaPath: ExprPath): LambdaVarKey;
    type: 'lambdaVarKey';
    lambdaPath: ExprPath;
    withLambdaPath(lambdaPath: ExprPath): LambdaVarKey;
    updateLambdaPath(updater: Updater<ExprPath>): LambdaVarKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

declare export class DefinitionKey {
    static make(defName: string): DefinitionKey;
    type: 'definitionKey';
    defName: string;
    withDefName(defName: string): DefinitionKey;
    updateDefName(updater: Updater<string>): DefinitionKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

declare export class DefinitionRefKey {
    static make(defName: string): DefinitionRefKey;
    type: 'definitionRefKey';
    defName: string;
    withDefName(defName: string): DefinitionRefKey;
    updateDefName(updater: Updater<string>): DefinitionRefKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

declare export class DefinitionEmptyBodyKey {
    static make(defName: string): DefinitionEmptyBodyKey;
    type: 'definitionEmptyBodyKey';
    defName: string;
    withDefName(defName: string): DefinitionEmptyBodyKey;
    updateDefName(updater: Updater<string>): DefinitionEmptyBodyKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

declare export class PaletteLambdaKey {
    static make(varName: string): PaletteLambdaKey;
    type: 'paletteLambdaKey';
    varName: string;
    withVarName(varName: string): PaletteLambdaKey;
    updateVarName(updater: Updater<string>): PaletteLambdaKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

declare export class PaletteReferenceKey {
    static make(defName: string): PaletteReferenceKey;
    type: 'paletteReferenceKey';
    defName: string;
    withDefName(defName: string): PaletteReferenceKey;
    updateDefName(updater: Updater<string>): PaletteReferenceKey;
    match<T>(visitor: ViewKeyVisitor<T>): T;
    serialize(): any;
}

export type ViewKey = ExpressionKey | EmptyBodyKey | LambdaVarKey | DefinitionKey | DefinitionRefKey | DefinitionEmptyBodyKey | PaletteLambdaKey | PaletteReferenceKey;

export type ViewKeyVisitor<T> = {
    expressionKey(expressionKey: ExpressionKey): T,
    emptyBodyKey(emptyBodyKey: EmptyBodyKey): T,
    lambdaVarKey(lambdaVarKey: LambdaVarKey): T,
    definitionKey(definitionKey: DefinitionKey): T,
    definitionRefKey(definitionRefKey: DefinitionRefKey): T,
    definitionEmptyBodyKey(definitionEmptyBodyKey: DefinitionEmptyBodyKey): T,
    paletteLambdaKey(paletteLambdaKey: PaletteLambdaKey): T,
    paletteReferenceKey(paletteReferenceKey: PaletteReferenceKey): T,
}

declare export class CanvasExpressionMapLens<K, Result> extends Lens<IMap<K, CanvasExpression>, Result> {
    atKey(key: K): CanvasExpressionLens<Result>;
    deleteKey(key: K): Result;
}

declare export class CanvasPointMapLens<K, Result> extends Lens<IMap<K, CanvasPoint>, Result> {
    atKey(key: K): CanvasPointLens<Result>;
    deleteKey(key: K): Result;
}

declare export class PendingResultMapLens<K, Result> extends Lens<IMap<K, PendingResult>, Result> {
    atKey(key: K): PendingResultLens<Result>;
    deleteKey(key: K): Result;
}

declare export class DragDataMapLens<K, Result> extends Lens<IMap<K, DragData>, Result> {
    atKey(key: K): DragDataLens<Result>;
    deleteKey(key: K): Result;
}

declare export class ScreenExpressionListLens<Result> extends Lens<IList<ScreenExpression>, Result> {
    atIndex(index: number): ScreenExpressionLens<Result>;
}

declare export class ScreenDefinitionListLens<Result> extends Lens<IList<ScreenDefinition>, Result> {
    atIndex(index: number): ScreenDefinitionLens<Result>;
}

declare export class MeasureRequestListLens<Result> extends Lens<IList<MeasureRequest>, Result> {
    atIndex(index: number): MeasureRequestLens<Result>;
}
