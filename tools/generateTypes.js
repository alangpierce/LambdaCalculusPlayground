/**
 * Code generator for the immutable types used by the library. We generate these
 * as a build step and check them into the repo to make the development
 * experience a little IDE-friendly and typesafe. Maybe eventually Flow will be
 * expressive enough to get everything we want, but not yet.
 *
 * TODO: Investigate if this could be done as a babel transform. Also check if
 * another thing like this already exists. Probably so, but it probably isn't
 * quite what I want, e.g. it probably wouldn't support unions like I want them.
 */
"use strict";

const generateTypes = (types) => {
    return `\
/**
 * Autogenerated; do not edit! Run "npm gen-types" to regenerate.
 *
 * @flow
 */
 
import * as Immutable from 'immutable'
 
${joinMap(types, '\n', genType)}
`;
};

const genType = (typeName, typeData) => {
    const lowerTypeName = lowerName(typeName);
    if (lowerTypeName === typeName) {
        throw new Error('Type names must be upper-case.');
    }

    if (typeData.type === 'literal') {
        return genLiteral(typeName, typeData.value);
    } else if (typeData.type === 'struct') {
        return genStruct(typeName, typeData.fields);
    } else if (typeData.type === 'union') {
        return genUnion(typeName, typeData.cases, false);
    } else if (typeData.type === 'objectUnion') {
        return genUnion(typeName, typeData.cases, true);
    }
};

const genLiteral = (typeName, value) => {
    return `\
export type ${typeName} = ${value};
`;
};

const genStruct = (typeName, fields) => {
    const {genLines, genComma} = fieldOperators(fields);
    return `\
class ${typeName}Impl extends Immutable.Record({
        ${genComma((f) => `${f}: undefined`)}}) {
${joinMap(fields, '', (f, t) => `\
    with${upperName(f)}(${f}) {
        return this.set('${f}', ${f})
    }
`)}\
${joinMap(fields, '', (f, t) => `\
    update${upperName(f)}(updater) {
        return this.set('${f}', updater(this.${f}))
    }
`)}\
}

export type ${typeName} = {
${genLines((f, t) => `${f}: ${t},`)}\
${genLines((f, t) => `with${upperName(f)}: (${f}: ${t}) => ${typeName},`)}\
${genLines((f, t) => `update${upperName(f)}: (updater: (${f}: ${t}) => ${t}) => ${typeName},`)}\
    toJS: () => any,
};

export const new${typeName} = (${genComma((f, t) => `${f}: ${t}`)}): ${typeName} => (new ${typeName}Impl({
${genLines((f, t) => `${f},`)}\
}));
`;
};

const genUnion = (typeName, cases, isObject) => {
    let result = '';
    result += joinMap(cases, '\n',
        (caseName, fields) => genUnionCase(caseName, fields, isObject));

    const varName = lowerName(typeName);

    // For the match function, we use normal functions instead of arrow
    // functions because WebStorm doesn't yet like type parameters on arrow
    // functions.
    // TODO: Move to arrow functions when WebStorm gets smarter.
    result += `
export type ${typeName} = ${joinMap(cases, ' | ', (caseName) => caseName)};

export type ${typeName}Visitor<T> = {
${joinMap(cases, '\n', (caseName) => `\
    ${lowerName(caseName)}: (${lowerName(caseName)}: ${caseName}) => T,`)}
}

export const match${typeName} = function<T>(${varName}: ${typeName}, visitor: ${typeName}Visitor<T>): T {
    switch (${varName}.type) {
${joinMap(cases, '\n', (caseName) => `\
        case '${lowerName(caseName)}':
            return visitor.${lowerName(caseName)}(${varName});`)}
        default:
            throw new Error('Unexpected type: ' + ${varName}.type);
    }
};
`;
    return result;
};

/**
 * Union cases are almost like structs, but they have a tag that isn't a
 * parameter, so we generate them independently.
 *
 * Also, we need to handle a special case where Redux actions need to be plain
 * objects.
 */
const genUnionCase = (caseName, fields, isObject) => {
    const tagName = lowerName(caseName);
    const {genLines, genComma} = fieldOperators(fields);
    return `\
${isObject ? '' : `\
class ${caseName}Impl extends Immutable.Record({
        type: undefined, ${genComma((f) => `${f}: undefined`)}}) {
${joinMap(fields, '', (f, t) => `\
    with${upperName(f)}(${f}) {
        return this.set('${f}', ${f})
    }
`)}\
${joinMap(fields, '', (f, t) => `\
    update${upperName(f)}(updater) {
        return this.set('${f}', updater(this.${f}))
    }
`)}\
}

`}\
export type ${caseName} = {
    type: '${tagName}',
${genLines((f, t) => `${f}: ${t},`)}\
${isObject ? '' : `\
${genLines((f, t) => `with${upperName(f)}: (${f}: ${t}) => ${caseName},`)}\
${genLines((f, t) => `update${upperName(f)}: (updater: (${f}: ${t}) => ${t}) => ${caseName},`)}\
    toJS: () => any,
`}\
};

export const new${caseName} = (${genComma((f, t) => `${f}: ${t}`)}): ${caseName} => (${isObject ? '' : `new ${caseName}Impl(`}{
    type: '${tagName}',
${genLines((f, t) => `${f},`)}\
}${isObject ? '' : `)`});
`;
};

const fieldOperators = (fields) => ({
    genLines: (transform) => {
        return joinMap(fields, '', (k, v) => '    ' + transform(k, v) + '\n');
    },
    genComma: (transform) => {
        return joinMap(fields, ', ', transform);
    }
});

const lowerName = (name) => {
    return name[0].toLowerCase() + name.slice(1);
};

const upperName = (name) => {
    return name[0].toUpperCase() + name.slice(1);
};

const joinMap = (obj, sep, transform) => {
    return Object.keys(obj).map(
        (key) => transform(key, obj[key])
    ).join(sep);
};

export default generateTypes;